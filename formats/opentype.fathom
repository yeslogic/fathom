//! # OpenType Font File Format

//~ example-data = [
//~   "data/opentype/*.ttf",
//~   "data/opentype/aots/*.otf",
//~   "data/opentype/woff/*.ttf",
//~   "data/opentype/woff2/*.ttf",
//~ ]

// -----------------------------------------------------------------------------

/// Reserved formats
let reserved = fun (format : Format) => fun (default : Repr format) =>
    format; // TODO: set to `default` during serialisation

/// Deprecated formats
let deprecated = fun (format : Format) => fun (default : Repr format) =>
    format; // TODO: set to `default` during serialisation


// -----------------------------------------------------------------------------

// # Common Formats
//
// Common formats to be used in the OpenType specification.
//
// ## References
//
// - [Microsoft's OpenType Spec: Data Types](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#data-types)
// - [Apple's TrueType Reference Manual: Data Types](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Types)

// TODO: move to separate module

/// Signed 32-bit fixed-point number (16.16)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Fixed](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_Fixed)
let fixed : Format = u32be;

/// Signed, 16-bit integer that describes a quantity in font design units.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: FWORD](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_FWORD)
let fword : Format = s16be;

/// Unsigned, 16-bit integer that describes a quantity in font design units.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: UFWORD](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_UFWORD)
let ufword : Format = u16be;

/// Signed 16-bit fixed number with the low 14 bits of fraction (2.14).
///
/// ## References
///
/// - [Microsoft's OpenType Spec: F2DOT14](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_F2DOT14)
let f2dot14 : Format = s16be;

/// Unsigned 24-bit integer
///
/// ## References
///
/// - [Microsoft's OpenType Spec: uint24](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_uint24)
let u24be : Format = array8 3 u8;

/// Date represented in number of seconds since 12:00 midnight, January 1, 1904.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LONGDATETIME](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_LONGDATETIME)
let long_date_time : Format = s64be;

/// Array of four `U8`s used to identify a table, design-variation axis, script,
/// language system, feature, or baseline.
///
/// The elements of the array are expected to be in the range [0x20, 0x7E].
/// This corresponds to the range of printable ASCII characters.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Tag](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_Tag)
let tag : Format =
    // TODO: constrain array elements to the range 0x20 to 0x7E.
    // TODO: pattern matching on arrays
    // array8 4 u8;
    u32be;

/// # Unknown table format
///
/// This is a placeholder for a table that has an unknown identifier (due to the
/// file conforming to a newer version of the specification), or for a table has
/// not yet been implemented.
let unknown_table : Format = {};

/// A format that consumes no input.
let empty : Format = {};

/// 16-bit offset to a `format`, relative to some `base` position.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Offset16](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_Offset16)
let offset16 = fun (base : Pos) => fun (format : Format) => {
    offset <- u16be,
    link <- match offset {
        0 => empty,
        _ => link (pos_add_u16 base offset) format, // TODO: Use an option type?
    },
};

/// 32-bit offset to a `format`, relative to some `base` position.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Offset32](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_Offset32)
let offset32 = fun (base : Pos) => fun (format : Format) => {
    offset <- u32be,
    link <- match offset {
        0 => empty,
        _ => link (pos_add_u32 base offset) format, // TODO: Use an option type?
    },
};

/// Packed 32-bit value with major and minor version numbers.
///
/// Used only in the 'maxp', 'post' and 'vhea' tables, for backward
/// compatibility reasons.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Version16Dot16](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#dt_Version16Dot16)
let version16dot16 = u32be;


// -----------------------------------------------------------------------------

/// # Platform identifiers
///
/// | Value         | Meaning                           |
/// | ------------- | --------------------------------- |
/// | `0`           | Unicode                           |
/// | `1`           | Macintosh                         |
/// | `2`           | ISO (deprecated in OpenType v1.3) |
/// | `3`           | Windows                           |
/// | `4`           | Custom                            |
/// | `5..<240`     | Reserved                          |
/// | `240..<256`   | User-defined                      |
///
/// Value `1` (Macintosh) is discouraged on current platforms – prefer a value
/// of `3` (Windows) for maximum compatibility.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Platform IDs](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#platform-ids)
/// - [Microsoft's OpenType Spec: Platform, encoding and language](https://docs.microsoft.com/en-us/typography/opentype/spec/name#platform-encoding-and-language)
/// - [Apple's TrueType Reference Manual: The `'cmap'` encoding subtables](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
/// - [Apple's TrueType Reference Manual: The platform identifier](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html)
let platform_id =
    u16be;

/// # Platform-specific encoding identifiers
///
// TODO: document encoding IDs
let encoding_id = fun (platform : Repr platform_id) =>
    u16be;

/// # Language identifiers
///
/// This must be set to `0` for all subtables that have a platform ID other than
/// ‘Macintosh’.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Use of the language field in 'cmap' subtables](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#use-of-the-language-field-in-cmap-subtables)
/// - [Apple's TrueType Reference Manual: The `'cmap'` table and language codes](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
///
// TODO: add more details to docs
let language_id =
    u16be;

let language_id32 =
    u32be;


// # Common Table Formats

/// # Class Definition Table
///
/// | Class | Description                                               |
/// |-------|-----------------------------------------------------------|
/// | 1     | Base glyph (single character, spacing glyph)              |
/// | 2     | Ligature glyph (multiple character, spacing glyph)        |
/// | 3     | Mark glyph (non-spacing combining glyph)                  |
/// | 4     | Component glyph (part of single character, spacing glyph) |
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Class Definition Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table)

/// # Class Definition Table Format 1
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Class Definition Table Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-1)
let class_def_format_1 = {
    /// First glyph ID of the class_value_array
    start_glyph_id <- u16be,
    /// Size of the class_value_array
    glyph_count <- u16be,
    /// Array of Class Values — one per glyph ID
    class_value_array <- array16 glyph_count u16be,
};

/// # Class Definition Table Format 2
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Class Definition Table Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table-format-2)
let class_def_format_2 = (
    /// ClassRangeRecord
    let class_range_record = {
        /// First glyph ID in the range
        start_glyph_id <- u16be,
        /// Last glyph ID in the range
        end_glyph_id <- u16be,
        /// Applied to all glyphs in the range
        class <- u16be,
    };

    {
        /// Number of ClassRangeRecords
        class_range_count <- u16be,
        /// Array of ClassRangeRecords — ordered by startGlyphID
        class_range_records <- array16 class_range_count class_range_record,
    }
);

/// # Class Definition Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Class Definition Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table)
let class_def = {
    /// Format identifier
    class_format <- u16be,
    /// Format specific data
    data <- match class_format {
        1 => class_def_format_1,
        2 => class_def_format_2,
        _ => unknown_table,
    },
};

/// # Coverage Format 1
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Coverage Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-1)
let coverage_format_1 = {
    /// Number of glyphs in the glyph array
    glyph_count <- u16be,
    /// Array of glyph IDs — in numerical order
    glyph_array <- array16 glyph_count u16be,
};

/// # Coverage Format 2
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Coverage Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-format-2)
let coverage_format_2 = (
    /// RangeRecord
    let range_record = {
        /// First glyph ID in the range
        start_glyph_id <- u16be,
        /// Last glyph ID in the range
        end_glyph_id <- u16be,
        /// Coverage Index of first glyph ID in range
        start_coverage_index <- u16be,
    };

    {
        /// Number of RangeRecords
        range_count <- u16be,
        /// Array of glyph ranges — ordered by startGlyphID
        range_records <- array16 range_count range_record,
    }
);

/// # Coverage Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Coverage Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverageTbl)
let coverage_table = {
    /// Format identifier
    coverage_format <- u16be,
    /// Format specific data
    data <- match coverage_format {
        1 => coverage_format_1,
        2 => coverage_format_2,
        _ => unknown_table,
    }
};

/// # Sequence Lookup Record
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Sequence Lookup Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-lookup-record)
let sequence_lookup_record = {
    /// Index (zero-based) into the input glyph sequence
    sequence_index <- u16be,
    /// Index (zero-based) into the LookupList
    lookup_list_index <- u16be,
};

/// # Device and VariationIndex Tables
///
/// Device tables and VariationIndex tables are used to provide adjustments to font-unit values in
/// GPOS, JSTF, GDEF or BASE tables, such as the X and Y coordinates of an attachment anchor
/// position.
///
/// Curiously the table has two interpretations. The second interprtation appears to be have been
/// tacked on for variable fonts. The gist being that if the delta format is 0x8000 then the table
/// is a VariationIndex table, which names the fields differently and does not contain a delta
/// value array. E.g.
///
/// let variation_index_table = {
///     /// A delta-set outer index — used to select an item variation data subtable within the item variation store.
///     delta_set_outer_index <- u16be,
///     /// A delta-set inner index — used to select a delta-set row within an item variation data subtable.
///     delta_set_inner_index <- u16be,
///     /// Format, = 0x8000
///     delta_format <- u16be,
/// };
///
/// We only define `device_table` and have it conditionally read the delta value array.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Device and VariationIndex Tables](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#device-and-variationindex-tables)
///
let device_table = (
    // quotient = numerator / denominator # int division
    // if quotient * denominator < numerator:
    //     quotient + 1
    // else:
    //     quotient
    let u16_div_ceil = fun (numerator : U16) => fun (denominator : U16) => (
        let quotient = u16_div numerator denominator;
        match (u16_lt (u16_mul quotient denominator) numerator) {
            true => u16_add quotient 1,
            false => quotient,
        }
    );

    let delta_bits = fun (delta_format : U16) => fun (num_sizes : U16) =>
        match delta_format {
            // Signed 2-bit value, 8 values per u16be
            0x0001 => u16_mul num_sizes 2,
            // Signed 4-bit value, 4 values per u16be
            0x0002 => u16_mul num_sizes 4,
            // Signed 8-bit value, 2 values per u16be
            0x0003 => u16_mul num_sizes 8,
            // Unreachable due to match done in device_or_variation_index_table
            _ => 0,
        };

    let num_sizes = fun (start : U16) => fun (end : U16) =>
        u16_add (u16_sub end start) 1;

    {
        /// Smallest size to correct, in ppem
        start_size <- u16be,
        /// Largest size to correct, in ppem
        end_size <- u16be,
        /// Format of deltaValue array data
        delta_format <- u16be,
        /// Array of compressed data
        delta_values <-
            let delta_bits = delta_bits delta_format (num_sizes start_size end_size);
            array16 (u16_div_ceil delta_bits 16) u16be,
    }
);

/// VariationIndex table
let variation_index_table = {
    /// A delta-set outer index — used to select an item variation data subtable within the item
    /// variation store.
    delta_set_outer_index <- u16be,
    /// A delta-set inner index — used to select a delta-set row within an item variation data
    /// subtable.
    delta_set_inner_index <- u16be,
};

let device_or_variation_index_table = overlap {
    // Initial pass to figure out the table format
    init <- {
        _skipped <- array8 4 u8,
        table_format <- u16be,
    },
    // Device and VariationIndex Tables
    table <- match init.table_format {
        0x0001 => device_table,
        0x0002 => device_table,
        0x0003 => device_table,
        0x8000 => variation_index_table,
        _ => unknown_table,
    },
};

/// # Language System Table
///
/// Also known as LangSys table.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Language System Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#language-system-table)
let lang_sys = {
    /// = NULL (reserved for an offset to a reordering table)
    lookup_order_offset <- u16be,
    /// Index of a feature required for this language system; if no required features = 0xFFFF
    required_feature_index <- u16be,
    /// Number of feature index values for this language system — excludes the required feature
    feature_index_count <- u16be,
    /// Array of indices into the FeatureList, in arbitrary order
    feature_indices <- array16 feature_index_count u16be,
};

/// # Language System Record
///
/// Also known as LangSys record.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Script Table and Language System Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-table-and-language-system-record)
let lang_sys_record = fun (script_start : Pos) => {
    /// 4-byte LangSysTag identifier
    lang_sys_tag <- tag,
    /// Offset to LangSys table, from beginning of Script table
    lang_sys <- offset16 script_start lang_sys,
};

/// # Script table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Script Table and Language System Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-table-and-language-system-record)
let script_table = {
    /// The start of the script table
    table_start <- stream_pos,
    /// Offset to default LangSys table, from beginning of Script table — may be NULL
    default_lang_sys <- offset16 table_start lang_sys,
    /// Number of LangSysRecords for this script — excluding the default LangSys
    lang_sys_count <- u16be,
    /// Array of LangSysRecords, listed alphabetically by LangSys tag
    lang_sys_records <- array16 lang_sys_count (lang_sys_record table_start),
};

/// # Script list table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Script List Table and Script Record](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#script-list-table-and-script-record)
let script_list = (
    /// ScriptRecord
    let script_record = fun (script_list_start : Pos) => {
        /// 4-byte script tag identifier
        script_tag <- tag,
        /// Offset to Script table, from beginning of ScriptList
        script <- offset16 script_list_start script_table,
    };

    {
        /// The start of the script list table
        table_start <- stream_pos,
        /// Number of ScriptRecords
        script_count <- u16be,
        /// Array of ScriptRecords, listed alphabetically by script tag
        script_records <- array16 script_count (script_record table_start),
    }
);

/// # Feature Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Feature Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-table)
let feature_table = {
    /// The start of the feature table
    table_start <- stream_pos,
    /// Offset from start of Feature table to FeatureParams table, if defined for the feature and
    /// present, else NULL
    feature_params <- u16be, // TODO: The format of the params table depends on the feature tag
    /// Number of LookupList indices for this feature
    lookup_index_count <- u16be,
    /// Array of indices into the LookupList — zero-based (first lookup is LookupListIndex = 0)
    lookup_list_indices <- array16 lookup_index_count u16be,
};

/// # Feature List Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Feature List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#feature-list-table)
let feature_list = (
    let feature_record = fun (feature_list_start : Pos) => {
        /// 4-byte feature identification tag
        feature_tag <- tag,
        /// Offset to Feature table, from beginning of FeatureList
        feature <- offset16 feature_list_start feature_table,
    };

    {
        /// The start of the feature list table
        table_start <- stream_pos,
        /// Number of FeatureRecords in this table
        feature_count <- u16be,
        /// Array of FeatureRecords — zero-based (first feature has FeatureIndex = 0), listed
        /// alphabetically by feature tag
        feature_records <- array16 feature_count (feature_record table_start),
    }
);

/// # Sequence Context Format 1: simple glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-1-simple-glyph-contexts)
let sequence_context_format1 = (
    /// SequenceRule table
    let sequence_rule = {
        /// Number of glyphs in the input glyph sequence
        glyph_count <- u16be,
        /// Number of SequenceLookupRecords
        seq_lookup_count <- u16be,
        /// Array of input glyph IDs—starting with the second glyph
        input_sequence <- array16 (u16_sub glyph_count 1) u16be,
        /// Array of Sequence lookup records
        seq_lookup_records <- array16 seq_lookup_count sequence_lookup_record,
    };

    /// SequenceRuleSet table—all contexts beginning with the same glyph
    let sequence_rule_set = {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of SequenceRule tables
        seq_rule_count <- u16be,
        /// Array of offsets to SequenceRule tables, from beginning of the SequenceRuleSet table
        seq_rules <- array16 seq_rule_count (offset16 table_start sequence_rule),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Offset to Coverage table, from beginning of SequenceContextFormat1 table
        coverage <- offset16 table_start coverage_table,
        /// Number of SequenceRuleSet tables
        seq_rule_set_count <- u16be,
        /// Array of offsets to SequenceRuleSet tables, from beginning of
        /// SequenceContextFormat1 table (offsets may be NULL)
        seq_rule_sets <- array16 seq_rule_set_count (offset16 table_start sequence_rule_set),
    }
);

/// # Sequence Context Format 2: class-based glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-2-class-based-glyph-contexts)
let sequence_context_format2 = (
    /// ClassSequenceRule table
    let class_sequence_rule = {
        /// Number of glyphs to be matched
        glyph_count <- u16be,
        /// Number of SequenceLookupRecords
        seq_lookup_count <- u16be,
        /// Sequence of classes to be matched to the input glyph sequence, beginning with the
        /// second glyph position
        input_sequence <- array16 (u16_sub glyph_count 1) u16be,
        /// Array of SequenceLookupRecords
        seqLookupRecords <- array16 seq_lookup_count sequence_lookup_record,
    };

    /// ClassSequenceRuleSet table
    let class_sequence_rule_set = {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of ClassSequenceRule tables
        class_seq_rule_count <- u16be,
        /// Array of offsets to ClassSequenceRule tables, from beginning of ClassSequenceRuleSet
        /// table
        class_seq_rules <- array16 class_seq_rule_count (offset16 table_start class_sequence_rule),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Offset to Coverage table, from beginning of SequenceContextFormat1 table
        coverage <- offset16 table_start coverage_table,
        /// Offset to ClassDef table, from beginning of SequenceContextFormat2 table
        class_def <- (offset16 table_start class_def),
        /// Number of ClassSequenceRuleSet tables
        class_seq_rule_set_count <- u16be,
        /// Array of offsets to ClassSequenceRuleSet tables, from beginning of
        /// SequenceContextFormat2 table (may be NULL)
        class_seq_rule_sets <- array16 class_seq_rule_set_count (offset16 table_start class_sequence_rule_set),
    }
);

/// # Sequence Context Format 3: coverage-based glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#sequence-context-format-3-coverage-based-glyph-contexts)
let sequence_context_format3 = {
    /// The start of the table
    table_start <- stream_pos,
    /// Number of glyphs in the input sequence
    glyph_count <- u16be,
    /// Number of SequenceLookupRecords
    seq_lookup_count <- u16be,
    /// Array of offsets to Coverage tables, from beginning of SequenceContextFormat3 subtable
    coverage_tables <- array16 glyph_count (offset16 table_start coverage_table),
    /// Array of SequenceLookupRecords
    seq_lookup_records <- array16 seq_lookup_count sequence_lookup_record,
};

let sequence_context = {
    /// Format identifier
    format <- u16be,
    /// Format specific substitutions
    subst <- match format {
        1 => sequence_context_format1,
        2 => sequence_context_format2,
        3 => sequence_context_format3,
        _ => unknown_table,
    }
};

/// # Chained Sequence Context Format 1: simple glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Chained Sequence Context Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-1-simple-glyph-contexts)
let chained_sequence_context_format_1 = (
    let chained_sequence_rule = {
        /// Number of glyphs in the backtrack sequence
        backtrack_glyph_count <- u16be,
        /// Array of backtrack glyph IDs
        backtrack_sequence <- array16 backtrack_glyph_count u16be,
        /// Number of glyphs in the input sequence
        input_glyph_count <- u16be,
        /// Array of input glyph IDs—start with second glyph
        input_sequence <- array16 (u16_sub input_glyph_count 1) u16be,
        /// Number of glyphs in the lookahead sequence
        lookahead_glyph_count <- u16be,
        /// Array of lookahead glyph IDs
        lookahead_sequence <- array16 lookahead_glyph_count u16be,
        /// Number of SequenceLookupRecords
        seq_lookup_count <- u16be,
        /// Array of SequenceLookupRecords
        seq_lookup_records <- array16 seq_lookup_count sequence_lookup_record,
    };

    let chained_sequence_rule_set = {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of ChainedSequenceRule tables
        chained_seq_rule_count <- u16be,
        /// Array of offsets to ChainedSequenceRule tables, from beginning of
        /// ChainedSequenceRuleSet table
        chained_seq_rules <- array16 chained_seq_rule_count (offset16 table_start chained_sequence_rule),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Offset to Coverage table, from beginning of ChainSequenceContextFormat1 table
        coverage <- (offset16 table_start coverage_table),
        /// Number of ChainedSequenceRuleSet tables
        chained_seq_rule_set_count <- u16be,
        /// Array of offsets to ChainedSeqRuleSet tables, from beginning of
        /// ChainedSequenceContextFormat1 table (may be NULL)
        chained_seq_rule_sets <- array16 chained_seq_rule_set_count (offset16 table_start chained_sequence_rule_set),
    }
);

/// # Chained Sequence Context Format 2: class-based glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Chained Sequence Context Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-2-class-based-glyph-contexts)
let chained_sequence_context_format_2 = (
    /// ChainedClassSequenceRule table
    let chained_class_sequence_rule = {
        /// Number of glyphs in the backtrack sequence
        backtrack_glyph_count <- u16be,
        /// Array of backtrack-sequence classes
        backtrack_sequence <- array16 backtrack_glyph_count u16be,
        /// Total number of glyphs in the input sequence
        input_glyph_count <- u16be,
        /// Array of input sequence classes, beginning with the second glyph position
        input_sequence <- array16 (u16_sub input_glyph_count 1) u16be,
        /// Number of glyphs in the lookahead sequence
        lookahead_glyph_count <- u16be,
        /// Array of lookahead-sequence classes
        lookahead_sequence <- array16 lookahead_glyph_count u16be,
        /// Number of SequenceLookupRecords
        seq_lookup_count <- u16be,
        /// Array of SequenceLookupRecords
        seq_lookup_records <- array16 seq_lookup_count sequence_lookup_record,
    };

    /// ChainedClassSequenceRuleSet table
    let chained_class_sequence_rule_set = {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of ChainedClassSequenceRule tables
        chained_class_seq_rule_count <- u16be,
        /// Array of offsets to ChainedClassSequenceRule tables, from beginning of
        /// ChainedClassSequenceRuleSet
        chained_class_seq_rules <- array16 chained_class_seq_rule_count (offset16 table_start chained_class_sequence_rule),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Offset to Coverage table, from beginning of ChainedSequenceContextFormat2 table
        coverage <- offset16 table_start coverage_table,
        /// Offset to ClassDef table containing backtrack sequence context, from beginning of
        /// ChainedSequenceContextFormat2 table
        backtrack_class_def <- offset16 table_start class_def,
        /// Offset to ClassDef table containing input sequence context, from beginning of
        /// ChainedSequenceContextFormat2 table
        input_class_def <- offset16 table_start class_def,
        /// Offset to ClassDef table containing lookahead sequence context, from beginning of
        /// ChainedSequenceContextFormat2 table
        lookahead_class_def <- offset16 table_start class_def,
        /// Number of ChainedClassSequenceRuleSet tables
        chained_class_seq_rule_set_count <- u16be,
        /// Array of offsets to ChainedClassSequenceRuleSet tables, from beginning of
        /// ChainedSequenceContextFormat2 table (may be NULL)
        chained_class_seq_rule_sets <- array16 chained_class_seq_rule_set_count (offset16 table_start chained_class_sequence_rule_set),
    }
);

/// # Chained Sequence Context Format 3: coverage-based glyph contexts
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Chained Sequence Context Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#chained-sequence-context-format-3-coverage-based-glyph-contexts)
let chained_sequence_context_format_3 = {
    /// The start of the table
    table_start <- stream_pos,
    /// Number of glyphs in the backtrack sequence
    backtrack_glyph_count <- u16be,
    /// Array of offsets to coverage tables for the backtrack sequence
    backtrack_coverages <- array16 backtrack_glyph_count (offset16 table_start coverage_table),
    /// Number of glyphs in the input sequence
    input_glyph_count <- u16be,
    /// Array of offsets to coverage tables for the input sequence
    input_coverage_tables <- array16 input_glyph_count (offset16 table_start coverage_table),
    /// Number of glyphs in the lookahead sequence
    lookahead_glyph_count <- u16be,
    /// Array of offsets to coverage tables for the lookahead sequence
    lookahead_coverages <- array16 lookahead_glyph_count (offset16 table_start coverage_table),
    /// Number of SequenceLookupRecords
    seq_lookup_count <- u16be,
    /// Array of SequenceLookupRecords
    seq_lookup_records <- array16 seq_lookup_count sequence_lookup_record,
};

let chained_sequence_context = {
    /// Format identifier
    format <- u16be,
    /// Format specific substitutions
    subst <- match format {
        1 => sequence_context_format1,
        2 => sequence_context_format2,
        3 => sequence_context_format3,
        _ => unknown_table,
    }
};

// # Lookup sub-tables

/// # LookupType 1: Single Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-1-single-substitution-subtable)
let single_substitution = {
    /// The start of the sub-table
    table_start <- stream_pos,
    /// Format identifier
    subst_format <- u16be,
    /// Coverage table
    coverage <- offset16 table_start coverage_table, // TODO move

    subst <- match subst_format {
        1 => {
            /// Add to original glyph ID to get substitute glyph ID
            delta_glyph_id <- s16be,
        },
        2 => {
            /// Number of glyph IDs in the substitute_glyph_ids array
            glyph_count <- u16be,
            /// Array of substitute glyph IDs — ordered by Coverage index
            substitute_glyph_ids <- array16 glyph_count u16be,
        },
        _ => unknown_table
    },
};

/// LookupType 2: Multiple Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-2-multiple-substitution-subtable)
let multiple_substitution = (
    let sequence_table = {
        /// Number of glyph IDs in the substitute_glyph_ids array. This must always be greater than
        /// 0.
        glyph_count <- u16be,
        /// String of glyph IDs to substitute
        substitute_glyph_ids <- array16 glyph_count u16be,
    };

    {
        /// The start of the sub-table
        table_start <- stream_pos,
        /// Format identifier
        subst_format <- u16be,
        /// Coverage table
        coverage <- offset16 table_start coverage_table,
        subst <- match subst_format {
            1 => {
                /// Number of Sequence table offsets in the sequences array
                sequence_count <- u16be,
                /// Array of offsets to Sequence tables. Offsets are from beginning of substitution
                /// subtable, ordered by Coverage index
                sequences <- array16 sequence_count (offset16 table_start sequence_table),
            },
            _ => unknown_table,
        },
    }
);

/// # LookupType 3: Alternate Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 3](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-3-alternate-substitution-subtable)
let alternate_substitution = (
    /// AlternateSet table
    let alternate_set = {
        /// Number of glyph IDs in the alternate_glyph_ids array
        glyph_count <- u16be,
        /// Array of alternate glyph IDs, in arbitrary order
        alternate_glyph_ids <- array16 glyph_count u16be,
    };

    {
        /// The start of the sub-table
        table_start <- stream_pos,
        /// Format identifier
        subst_format <- u16be,
        /// Coverage table
        coverage <- offset16 table_start coverage_table,
        subst <- match subst_format {
            1 => {
                /// Number of AlternateSet tables
                alternate_set_count <- u16be,
                /// Array of offsets to AlternateSet tables. Offsets are from beginning of
                /// substitution subtable, ordered by Coverage index
                alternate_sets <- array16 alternate_set_count (offset16 table_start alternate_set),
            },
            _ => unknown_table,
        },
    }
);

/// # LookupType 4: Ligature Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 4](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-4-ligature-substitution-subtable)
let ligature_substitution = (
    /// Ligature table: Glyph components for one ligature
    let ligature_table = {
        /// glyph ID of ligature to substitute
        ligature_glyph <- u16be,
        /// Number of components in the ligature
        component_count <- u16be,
        /// Array of component glyph IDs — start with the second component, ordered in writing
        /// direction
        component_glyph_ids <- array16 (u16_sub component_count 1) u16be,
    };

    /// LigatureSet table: All ligatures beginning with the same glyph
    let ligature_set = {
        /// The start of the LigatureSet table
        table_start <- stream_pos,
        /// Number of Ligature tables
        ligature_count <- u16be,
        /// Array of offsets to Ligature tables. Offsets are from beginning of LigatureSet table,
        /// ordered by preference.
        ///
        /// For each ligature in the set, a Ligature table specifies the glyph ID of the output
        /// ligature glyph (ligatureGlyph); a count of the total number of component glyphs in the
        /// ligature, including the first component (componentCount); and an array of glyph IDs for
        /// the components (componentGlyphIDs). The array starts with the second component glyph in
        /// the ligature (glyph sequence index = 1, componentGlyphIDs array index = 0) because the
        /// first component glyph is specified in the Coverage table.
        ligatures <- array16 ligature_count (offset16 table_start ligature_table),
    };

    {
        /// The start of the sub-table
        table_start <- stream_pos,
        /// Format identifier
        subst_format <- u16be,
        /// Coverage table
        coverage <- offset16 table_start coverage_table,
        subst <- match subst_format {
            1 => {
                /// Number of LigatureSet tables
                ligature_set_count <- u16be,
                /// Array of offsets to LigatureSet tables. Offsets are from beginning of
                /// substitution subtable, ordered by Coverage index
                ligature_sets <- array16 ligature_set_count (offset16 table_start ligature_set),
            },
            _ => unknown_table,
        },
    }
);

/// # LookupType 5: Contextual Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 5](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-5-contextual-substitution-subtable)
let contextual_substitution = sequence_context;

/// # LookupType 6: Chained Contexts Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 6](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-6-chained-contexts-substitution-subtable)
let chained_contexts_substitution = chained_sequence_context;

/// # LookupType 8: Reverse Chaining Contextual Single Substitution Subtable
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 8](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-8-reverse-chaining-contextual-single-substitution-subtable)
let reverse_chaining_contextual_single_substitution = (
    /// ReverseChainSingleSubstFormat1 Subtable
    let reverse_chain_single_subst_format1 = {
        /// The start of the table
        table_start <- stream_pos,
        /// Offset to Coverage table, from beginning of substitution subtable.
        coverage <- offset16 table_start coverage_table,
        /// Number of glyphs in the backtrack sequence.
        backtrack_glyph_count <- u16be,
        /// Array of offsets to coverage tables in backtrack sequence, in glyph sequence order.
        backtrack_coverage_tables <- array16 backtrack_glyph_count (offset16 table_start coverage_table),
        /// Number of glyphs in lookahead sequence.
        lookahead_glyph_count <- u16be,
        /// Array of offsets to coverage tables in lookahead sequence, in glyph sequence order.
        lookahead_coverage_tables <- array16 lookahead_glyph_count (offset16 table_start coverage_table),
        /// Number of glyph IDs in the substituteGlyphIDs array.
        glyph_count <- u16be,
        /// Array of substitute glyph IDs — ordered by Coverage index.
        substitute_glyph_ids <- array16 glyph_count u16be,
    };

    {
        /// Format identifier
        subst_format <- u16be,
        subtable <- match subst_format {
            1 => reverse_chain_single_subst_format1,
            _ => unknown_table,
        }
    }
);

// This one is out of order as it needs to refer to all the other substitutions
/// # LookupType 7: Extension Substitution
///
/// ## References
///
/// - [Microsoft's OpenType Spec: LookupType 7](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub#lookuptype-7-extension-substitution)
let extension_substitution = (
    /// ExtensionSubstFormat1 subtable
    let extension_subst_format1 = {
        /// The start of the table
        table_start <- stream_pos,
        /// Lookup type of subtable referenced by extensionOffset (that is, the extension subtable).
        ///
        /// The extensionLookupType field must be set to any lookup type other than 7.
        extension_lookup_type <- u16be,
        /// Offset to the extension subtable, of lookup type extensionLookupType, relative to the
        /// start of the ExtensionSubstFormat1 subtable.
        extension_subtable <- match extension_lookup_type {
            // Keep in sync with lookup_table GSUB block
            1 => single_substitution,
            2 => multiple_substitution,
            3 => alternate_substitution,
            4 => ligature_substitution,
            5 => contextual_substitution,
            6 => chained_contexts_substitution,
            7 => fail,
            8 => reverse_chaining_contextual_single_substitution,
            _ => unknown_table,

            // TODO: just call back into lookup_table when that's possible
            // 7 => fail,
            // _ => offset32 table_start (lookup_table "GSUB"),
        }
    };

    {
        /// Format identifier
        subst_format <- u16be,
        subtable <- match subst_format {
            1 => extension_subst_format1,
            _ => unknown_table,
        }
    }
);


// GPOS:
//
// | Type | Name                        | Description                                    |
// |------|-----------------------------|------------------------------------------------|
// | 1    | Single adjustment           | Adjust position of a single glyph              |
// | 2    | Pair adjustment             | Adjust position of a pair of glyphs            |
// | 3    | Cursive attachment          | Attach cursive glyphs                          |
// | 4    | MarkToBase attachment       | Attach a combining mark to a base glyph        |
// | 5    | MarkToLigature attachment   | Attach a combining mark to a ligature          |
// | 6    | MarkToMark attachment       | Attach a combining mark to another mark        |
// | 7    | Context positioning         | Position one or more glyphs in context         |
// | 8    | Chained Context positioning | Position one or more glyphs in chained context |
// | 9    | Extension positioning       | Extension mechanism for other positionings     |
// | 10   | Reserved                    | For future use (set to zero)                   |

/// # Value Record
///
/// Note that all fields of a ValueRecord are optional: to save space, only the fields that are
/// required need be included in a given instance. Because the GPOS table uses ValueRecords for
/// many purposes, the sizes and contents of ValueRecords may vary from subtable to subtable.
///
/// A ValueRecord is always accompanied by a ValueFormat flags field that specifies which of the
/// ValueRecord fields is present. If a ValueRecord specifies more than one value, the values must
/// be listed in the order shown in the ValueRecord definition. If the associated ValueFormat flags
/// indicate that a field is not present, then the next present field follows immediately after the
/// last preceding, present field.
///
/// ## Value Format Flags
///
/// |  Mask  |        Name        |                                                Description                                                |
/// |:------:|:------------------:|:---------------------------------------------------------------------------------------------------------:|
/// | 0x0001 | X_PLACEMENT        | Includes horizontal adjustment for placement                                                              |
/// | 0x0002 | Y_PLACEMENT        | Includes vertical adjustment for placement                                                                |
/// | 0x0004 | X_ADVANCE          | Includes horizontal adjustment for advance                                                                |
/// | 0x0008 | Y_ADVANCE          | Includes vertical adjustment for advance                                                                  |
/// | 0x0010 | X_PLACEMENT_DEVICE | Includes Device table (non-variable font) / VariationIndex table (variable font) for horizontal placement |
/// | 0x0020 | Y_PLACEMENT_DEVICE | Includes Device table (non-variable font) / VariationIndex table (variable font) for vertical placement   |
/// | 0x0040 | X_ADVANCE_DEVICE   | Includes Device table (non-variable font) / VariationIndex table (variable font) for horizontal advance   |
/// | 0x0080 | Y_ADVANCE_DEVICE   | Includes Device table (non-variable font) / VariationIndex table (variable font) for vertical advance     |
/// | 0xFF00 | Reserved           | For future use (set to zero)                                                                              |
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Value Record](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record)
let value_record = fun (table_start : Pos) => fun (flags : U16) => (
    let X_PLACEMENT : U16 = 0x0001;
    let Y_PLACEMENT : U16 = 0x0002;
    let X_ADVANCE : U16 = 0x0004;
    let Y_ADVANCE : U16 = 0x0008;
    let X_PLACEMENT_DEVICE : U16 = 0x0010;
    let Y_PLACEMENT_DEVICE : U16 = 0x0020;
    let X_ADVANCE_DEVICE : U16 = 0x0040;
    let Y_ADVANCE_DEVICE : U16 = 0x0080;

    let optional_field = fun (field : U16) => fun (format : Format) =>
        match (u16_neq (u16_and flags field) 0) {
            true => format,
            false => empty,
        };

    {
        /// Horizontal adjustment for placement, in design units.
        x_placement <- optional_field X_PLACEMENT s16be,
        /// Vertical adjustment for placement, in design units.
        y_placement <- optional_field Y_PLACEMENT s16be,
        /// Horizontal adjustment for advance, in design units — only used for horizontal layout.
        x_advance <- optional_field X_ADVANCE s16be,
        /// Vertical adjustment for advance, in design units — only used for vertical layout.
        y_advance <- optional_field Y_ADVANCE s16be,
        /// Offset to Device table (non-variable font) / VariationIndex table (variable font) for
        /// horizontal placement, from beginning of the immediate parent table (SinglePos or
        /// PairPosFormat2 lookup subtable, PairSet table within a PairPosFormat1 lookup subtable)
        /// — may be NULL.
        x_pla_device_offset <- optional_field X_PLACEMENT_DEVICE (offset16 table_start device_or_variation_index_table),
        /// Offset to Device table (non-variable font) / VariationIndex table (variable font) for
        /// vertical placement, from beginning of the immediate parent table (SinglePos or
        /// PairPosFormat2 lookup subtable, PairSet table within a PairPosFormat1 lookup subtable)
        /// — may be NULL.
        y_pla_device_offset <- optional_field Y_PLACEMENT_DEVICE (offset16 table_start device_or_variation_index_table),
        /// Offset to Device table (non-variable font) / VariationIndex table (variable font) for
        /// horizontal advance, from beginning of the immediate parent table (SinglePos or
        /// PairPosFormat2 lookup subtable, PairSet table within a PairPosFormat1 lookup subtable)
        /// — may be NULL.
        x_adv_device_offset <- optional_field X_ADVANCE_DEVICE (offset16 table_start device_or_variation_index_table),
        /// Offset to Device table (non-variable font) / VariationIndex table (variable font) for
        /// vertical advance, from beginning of the immediate parent table (SinglePos or
        /// PairPosFormat2 lookup subtable, PairSet table within a PairPosFormat1 lookup subtable)
        /// — may be NULL.
        y_adv_device_offset <- optional_field Y_ADVANCE_DEVICE (offset16 table_start device_or_variation_index_table),
    }
);

/// A value record that is `empty` if flags is 0
let optional_value_record = fun (table_start : Pos) => fun (flags : U16) => match (u16_eq flags 0) {
    true => empty,
    false => value_record table_start flags
};

/// # Anchor Tables
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Anchor Tables](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#anchor-tables)
let anchor_table = {
    /// Format identifier
    anchor_format <- u16be,
    table <- match anchor_format {
        // Anchor Table Format 1: Design Units
        1 => {
            /// Horizontal value, in design units
            x_coordinate <- s16be,
            /// Vertical value, in design units
            y_coordinate <- s16be,
        },
        // Anchor Table Format 2: Design Units Plus Contour Point
        2 => {
            /// Horizontal value, in design units
            x_coordinate <- s16be,
            /// Vertical value, in design units
            y_coordinate <- s16be,
            /// Index to glyph contour point
            anchor_point <- u16be,
        },
        // Anchor Table Format 3: Design Units Plus Device or VariationIndex Tables
        // TODO
        _ => unknown_table,
    }
};

/// # Mark Array Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Mark Array Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#mark-array-table)
let mark_array_table = (
    /// MarkRecord
    let mark_record = fun (table_start : Pos) => {
        /// Class defined for the associated mark.
        mark_class <- u16be,
        /// Offset to Anchor table, from beginning of MarkArray table.
        mark_anchor_offset <- offset16 table_start anchor_table,
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of MarkRecords
        mark_count <- u16be,
        /// Array of MarkRecords, ordered by corresponding glyphs in the associated mark Coverage table.
        mark_records <- array16 mark_count (mark_record table_start),
    }
);

/// # GPOS Lookup Type 1: Single Adjustment Positioning Subtable
///
/// Also known as SinglePos.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable)
let single_adjustment = (
    /// Single Adjustment Positioning Format 1: Single Positioning Value
    let single_pos_format1 = fun (table_start : Pos) => {
        /// Offset to Coverage table, from beginning of SinglePos subtable.
        coverage_offset <- offset16 table_start coverage_table,
        /// Defines the types of data in the ValueRecord.
        value_format <- u16be,
        /// Defines positioning value(s) — applied to all glyphs in the Coverage table.
        value_record <- value_record table_start value_format,
    };

    /// Single Adjustment Positioning Format 2: Array of Positioning Values
    let single_pos_format2 = fun (table_start : Pos) => {
        /// Offset to Coverage table, from beginning of SinglePos subtable.
        coverage_offset <- offset16 table_start coverage_table,
        /// Defines the types of data in the ValueRecords.
        value_format <- u16be,
        /// Number of ValueRecords — must equal glyphCount in the Coverage table.
        value_count <- u16be,
        /// Array of ValueRecords — positioning values applied to glyphs.
        value_records <- array16 value_count (value_record table_start value_format),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Format identifier
        pos_format <- u16be,
        /// Format specific table
        subtable <- match pos_format {
            1 => single_pos_format1 table_start,
            2 => single_pos_format2 table_start,
            _ => unknown_table,
        }
    }
);

/// # GPOS Lookup Type 2: Pair Adjustment Positioning Subtable
///
/// A pair adjustment positioning subtable (PairPos).
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable)
let pair_adjustment = (
    /// PairValueRecord
    let pair_value_record = fun (table_start : Pos) => fun (value_format1 : U16) => fun (value_format2 : U16) => {
        /// Glyph ID of second glyph in the pair (first glyph is listed in the Coverage table).
        second_glyph <- u16be,
        /// Positioning data for the first glyph in the pair.
        value_record1 <- optional_value_record table_start value_format1,
        /// Positioning data for the second glyph in the pair.
        value_record2 <- optional_value_record table_start value_format2,
    };

    /// PairSet Table
    let pair_set = fun (value_format1 : U16) => fun (value_format2 : U16) => {
        /// The start of the table
        table_start <- stream_pos,
        /// Number of PairValueRecords
        pair_value_count <- u16be,
        /// Array of PairValueRecords, ordered by glyph ID of the second glyph.
        pair_value_records <- array16 pair_value_count (pair_value_record table_start value_format1 value_format2),
    };

    /// Pair Adjustment Positioning Format 1: Adjustments for Glyph Pairs (PairPosFormat1)
    let pair_pos_format1 = fun (table_start : Pos) => {
        /// Offset to Coverage table, from beginning of PairPos subtable.
        coverage <- offset16 table_start coverage_table,
        /// Defines the types of data in valueRecord1 — for the first glyph in the pair (may be
        /// zero).
        value_format1 <- u16be,
        /// Defines the types of data in valueRecord2 — for the second glyph in the pair (may be
        /// zero).
        value_format2 <- u16be,
        /// Number of PairSet tables
        pair_set_count <- u16be,
        /// Array of offsets to PairSet tables. Offsets are from beginning of PairPos subtable,
        /// ordered by Coverage Index.
        pair_sets <- array16 pair_set_count (offset16 table_start (pair_set value_format1 value_format2)),
    };

    /// Class2Record
    let class2_record = fun (table_start : Pos) => fun (value_format1 : U16) => fun (value_format2 : U16) => {
        /// Positioning for first glyph — empty if valueFormat1 = 0.
        value_record1 <- optional_value_record table_start value_format1,
        /// Positioning for second glyph — empty if valueFormat2 = 0.
        value_record2 <- optional_value_record table_start value_format2,
    };

    /// Class1Record
    let class1_record = fun (table_start : Pos) => fun (class2_count : U16) => fun (value_format1 : U16) => fun (value_format2 : U16) => {
        /// Array of Class2 records, ordered by classes in classDef2.
        class2_records <- array16 class2_count (class2_record table_start value_format1 value_format2),
    };

    /// Pair Adjustment Positioning Format 2: Class Pair Adjustment (PairPosFormat2)
    let pair_pos_format2 = fun (pair_pos_start : Pos) => {
        /// Offset to Coverage table, from beginning of PairPos subtable.
        coverage <- offset16 pair_pos_start coverage_table,
        /// ValueRecord definition — for the first glyph of the pair (may be zero).
        value_format1 <- u16be,
        /// ValueRecord definition — for the second glyph of the pair (may be zero).
        value_format2 <- u16be,
        /// Offset to ClassDef table, from beginning of PairPos subtable — for the first glyph of
        /// the pair.
        class_def1 <- offset16 pair_pos_start class_def,
        /// Offset to ClassDef table, from beginning of PairPos subtable — for the second glyph of
        /// the pair.
        class_def2 <- offset16 pair_pos_start class_def,
        /// Number of classes in classDef1 table — includes Class 0.
        class1_count <- u16be,
        /// Number of classes in classDef2 table — includes Class 0.
        class2_count <- u16be,
        /// Array of Class1 records, ordered by classes in classDef1.
        class1_records <- array16 class1_count (class1_record pair_pos_start class2_count value_format1 value_format2),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Format identifier
        pos_format <- u16be,
        /// Format specific table
        subtable <- match pos_format {
            1 => pair_pos_format1 table_start,
            2 => pair_pos_format2 table_start,
            _ => unknown_table,
        }
    }
);

/// # GPOS Lookup Type 3: Cursive Attachment Positioning Subtable
///
/// Also known as CursivePos.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 3](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-3-cursive-attachment-positioning-subtable)
let cursive_attachment = (
    /// EntryExitRecord
    let entry_exit_record = fun (table_start : Pos) => {
        /// Offset to entry Anchor table, from beginning of CursivePos subtable (may be NULL).
        entry_anchor <- offset16 table_start anchor_table,
        /// Offset to exit Anchor table, from beginning of CursivePos subtable (may be NULL).
        exit_anchor <- offset16 table_start anchor_table,
    };


    /// CursivePosFormat1 Subtable
    let cursive_pos_format1 = fun (table_start : Pos) => {
        /// Offset to Coverage table, from beginning of CursivePos subtable.
        coverage <- offset16 table_start coverage_table,
        /// Number of EntryExit records
        entry_exit_count <- u16be,
        /// Array of EntryExit records, in Coverage index order.
        entry_exit_record <- array16 entry_exit_count (entry_exit_record table_start),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Format identifier
        pos_format <- u16be,
        /// Format specific table
        subtable <- match pos_format {
            1 => cursive_pos_format1 table_start,
            _ => unknown_table,
        }
    }
);

/// # GPOS Lookup Type 4: Mark-to-Base Attachment Positioning Subtable
///
/// Also known as MarkBasePos.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 4](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-4-mark-to-base-attachment-positioning-subtable)
let mark_to_base_attachment = (
    /// BaseRecord
    let base_record = fun (table_start : Pos) => fun (mark_class_count : U16) => {
        /// Array of offsets (one per mark class) to Anchor tables. Offsets are from beginning of
        /// BaseArray table, ordered by class (offsets may be NULL).
        base_anchors <- array16 mark_class_count (offset16 table_start anchor_table),
    };

    /// BaseArray Table
    let base_array_table = fun (table_start : Pos) => fun (mark_class_count : U16) => {
        /// Number of BaseRecords
        base_count <- u16be,
        /// Array of BaseRecords, in order of baseCoverage Index.
        base_records <- array16 base_count (base_record table_start mark_class_count),
    };

    /// MarkBasePosFormat1 Subtable
    let mark_base_pos_format1 = fun (table_start : Pos) => {
        /// Offset to markCoverage table, from beginning of MarkBasePos subtable.
        mark_coverage <- offset16 table_start coverage_table,
        /// Offset to baseCoverage table, from beginning of MarkBasePos subtable.
        base_coverage <- offset16 table_start coverage_table,
        /// Number of classes defined for marks
        mark_class_count <- u16be,
        /// Offset to MarkArray table, from beginning of MarkBasePos subtable.
        mark_array <- offset16 table_start mark_array_table,
        /// Offset to BaseArray table, from beginning of MarkBasePos subtable.
        base_array <- offset16 table_start (base_array_table table_start mark_class_count),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Format identifier
        pos_format <- u16be,
        /// Format specific table
        subtable <- match pos_format {
            1 => mark_base_pos_format1 table_start,
            _ => unknown_table,
        }
    }
);

/// # GPOS Lookup Type 5: Mark-to-Ligature Attachment Positioning Subtable
///
/// Also known as MarkLigPos.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 5](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-5-mark-to-ligature-attachment-positioning-subtable)
let mark_to_ligature_attachment = (
    let component_record = fun (table_start : Pos) => fun (mark_class_count : U16) => {
        /// Array of offsets (one per class) to Anchor tables. Offsets are from beginning of
        /// LigatureAttach table, ordered by class (offsets may be NULL).
        ligature_anchors <- array16 mark_class_count (offset16 table_start anchor_table),
    };

    /// LigatureAttach Table
    let ligature_attach = fun (table_start : Pos) => fun (mark_class_count : U16) => {
        /// Number of ComponentRecords in this ligature
        component_count <- u16be,
        /// Array of Component records, ordered in writing direction.
        component_records <- array16 component_count (component_record table_start mark_class_count),
    };

    /// LigatureArray Table
    let ligature_array = fun (table_start : Pos) => fun (mark_class_count : U16) => {
        /// Number of LigatureAttach table offsets
        ligature_count <- u16be,
        /// Array of offsets to LigatureAttach tables. Offsets are from beginning of LigatureArray
        /// table, ordered by ligatureCoverage index.
        ligature_attaches <- array16 ligature_count (offset16 table_start (ligature_attach table_start mark_class_count)),
    };

    /// MarkLigPosFormat1 Subtable
    let mark_lig_pos_format1 = fun (table_start : Pos) => {
        /// Offset to markCoverage table, from beginning of MarkLigPos subtable.
        mark_coverage <- offset16 table_start coverage_table,
        /// Offset to ligatureCoverage table, from beginning of MarkLigPos subtable.
        ligature_coverage <- offset16 table_start coverage_table,
        /// Number of defined mark classes
        mark_class_count <- u16be,
        /// Offset to MarkArray table, from beginning of MarkLigPos subtable.
        mark_array <- offset16 table_start mark_array_table,
        /// Offset to LigatureArray table, from beginning of MarkLigPos subtable.
        ligature_array <- offset16 table_start (ligature_array table_start mark_class_count),
    };

    {
        /// The start of the table
        table_start <- stream_pos,
        /// Format identifier
        pos_format <- u16be,
        /// Format specific table
        subtable <- match pos_format {
            1 => mark_lig_pos_format1 table_start,
            _ => unknown_table,
        }
    }
);

/// # GPOS Lookup Type 6: Mark-to-Mark Attachment Positioning Subtable
///
/// The MarkToMark attachment (MarkMarkPos) subtable is identical in form to the MarkToBase
/// attachment subtable, although its function is different.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GPOS Lookup Type 6](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-6-mark-to-mark-attachment-positioning-subtable)
let mark_to_mark_attachment = mark_to_base_attachment;

/// # Lookup table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Lookup Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-table)
let lookup_table = fun (tag : U32) => (
    let USE_MARK_FILTERING_SET : U16 = 0x0010;

    let lookup_subtable = fun (tag : U32) => fun (lookup_type : U16) =>
        match tag {
            "GSUB" => match lookup_type {
                1 => single_substitution,
                2 => multiple_substitution,
                3 => alternate_substitution,
                4 => ligature_substitution,
                5 => contextual_substitution,
                6 => chained_contexts_substitution,
                7 => extension_substitution,
                8 => reverse_chaining_contextual_single_substitution,
                _ => unknown_table,
            },
            "GPOS" => match lookup_type {
                1 => single_adjustment,
                2 => pair_adjustment,
                3 => cursive_attachment,
                4 => mark_to_base_attachment,
                5 => mark_to_ligature_attachment,
                6 => mark_to_mark_attachment,
                _ => unknown_table,
            },
            _ => fail,
        };

    {
        /// The start of the lookup table
        table_start <- stream_pos,
        /// Different enumerations for GSUB and GPOS
        lookup_type <- u16be,
        /// Lookup qualifiers
        lookup_flag <- u16be,
        /// Number of subtables for this lookup
        sub_table_count <- u16be,
        /// Array of offsets to lookup subtables, from beginning of Lookup table
        subtables <- array16 sub_table_count (offset16 table_start (lookup_subtable tag lookup_type)),
        /// Index (base 0) into GDEF mark glyph sets structure. This field is only present if the
        /// USE_MARK_FILTERING_SET lookup flag is set.
        mark_filtering_set <- match (u16_neq (u16_and lookup_flag USE_MARK_FILTERING_SET) 0) {
            true => u16be,
            false =>{},
        },
    }
);

/// # Lookup List Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Lookup List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#lookup-list-table)
let lookup_list = fun (tag : U32) => {
    /// The start of the lookup list table
    table_start <- stream_pos,
    /// Number of lookups in this table
    lookup_count <- u16be,
    /// Array of offsets to Lookup tables, from beginning of LookupList
    lookups <- array16 lookup_count (offset16 table_start (lookup_table tag)),
};

// -----------------------------------------------------------------------------

// # Chararacter to Glyph Index Mappings
//
// Formats related to the character mapping table. This table is responsible for
// mapping character codes to glyph indices used in the font.
//
// ## References
//
// - [Microsoft's OpenType Spec: cmap — Character to Glyph Index Mapping Table](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap)
// - [Apple's TrueType Reference Manual: The `'cmap'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)


/// # Language identifiers
///
/// This must be set to `0` for all subtables that have a platform ID other than
/// ‘Macintosh’.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Use of the language field in 'cmap' subtables](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#use-of-the-language-field-in-cmap-subtables)
/// - [Apple's TrueType Reference Manual: : The `'cmap'` table and language codes](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
///
// TODO: add more details to docs
let cmap_language_id = fun (platform : Repr platform_id) =>
    language_id;

// cmap sub-table format 8 has a 32-bit language code
let cmap_language_id32 = fun (platform : Repr platform_id) =>
    language_id32;

/// A small glyph ID, limited to a glyph set of 256 glyphs.
let small_glyph_id = u8;

/// # SequentialMapGroup Record
///
/// Each sequential map group record specifies a character range and the starting glyph ID mapped
/// from the first character. Glyph IDs for subsequent characters follow in sequence.
///
/// Used in `cmap` sub-table formats 8 and 12.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 8](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-8-mixed-16-bit-and-32-bit-coverage)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 8](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let sequential_map_group = {
    /// First character code in this group; note that if this group is for one or more 16-bit
    /// character codes (which is determined from the is32 array), this 32-bit value will have the
    /// high 16-bits set to zero
    start_char_code <- u32be,
    /// Last character code in this group; same condition as listed above for the startCharCode
    end_char_code <- u32be,
    /// Glyph index corresponding to the starting character code
    start_glyph_id <- u32be,
};

/// # ConstantMapGroup Record
///
/// The constant map group record has the same structure as the sequential map group record, with
/// start and end character codes and a mapped glyph ID. However, the same glyph ID applies to all
/// characters in the specified range rather than sequential glyph IDs.
///
/// Used in `cmap` sub-table format 13.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 13](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-13-many-to-one-range-mappings)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 13](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let constant_map_group = sequential_map_group;

/// # UnicodeRange Record
///
/// A range record from the DefaultUVS Table used in `cmap` sub-table format 14.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let unicode_range = {
    /// First value in this range
    start_unicode_value <- u24be,
    /// Number of additional values in this range
    additional_count <- u8,
};

/// # DefaultUVS Table
///
/// A range-compressed list of Unicode scalar values used in `cmap` sub-table format 14.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let default_uvs_table = {
    /// Number of Unicode character ranges.
    num_unicode_value_ranges <- u32be,
    /// Array of UnicodeRange records.
    ranges <- array32 num_unicode_value_ranges unicode_range,
};

/// # UVSMapping Record
///
/// A glyph ID mapping for one base Unicode character used in `cmap` sub-table format 14
/// NonDefaultUVS Table.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let uvs_mapping = {
    /// Base Unicode value of the UVS
    unicode_value <- u24be,
    /// Glyph ID of the UVS
    glyph_id <- u16be,
};

/// # NonDefaultUVS Table
///
/// A Non-Default UVS Table is a list of pairs of Unicode scalar values and glyph IDs.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let non_default_uvs_table = {
    /// Number of UVS Mappings that follow
    num_uvs_mappings <- u32be,
    /// Array of UVSMapping records.
    uvs_mappings <- array32 num_uvs_mappings uvs_mapping,
};

/// # VariationSelector Record for cmap sub-table format 14
///
/// Each variation selector record specifies a variation selector character, and offsets to
/// default and non-default tables used to map variation sequences using that variation selector.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: cmap sub-table format 14](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let variation_selector = fun (table_start : Pos) => {
    /// Variation selector
    var_selector <- u24be,
    /// Offset from the start of the format 14 subtable to Default UVS Table. May be 0.
    default_uvs_offset <- offset32 table_start default_uvs_table,
    /// Offset from the start of the format 14 subtable to Non-Default UVS Table. May be 0.
    non_default_uvs_offset <- offset32 table_start non_default_uvs_table,
};

/// # Format 0: Byte encoding table
///
/// A character mapping table for fonts with character codes and glyph indices
/// that can be stored within single bytes.
///
/// This table but was originally used as the standard character mapping table
/// on older Macintosh platforms when TrueType was first introduced, but is no
/// longer required on as fonts have become larger.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 0: Byte encoding table](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-0-byte-encoding-table)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 0](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format0 = fun (platform : Repr platform_id) => {
    /// The length of the subtable in bytes
    length <- u16be,
    /// The language ID of the subtable
    language <- cmap_language_id platform,
    /// A 1 to 1 mapping that converts character codes to glyph indexes (limited
    /// to 256 glyphs). Only the first 256 glyphs will be accessible for larger
    /// glyph sets.
    glyph_id_array <- array16 256 small_glyph_id,
};

/// # Format 2: High-byte mapping through table
///
/// This subtable format was created for “double-byte” encodings following the national character
/// code standards used for Japanese, Chinese, and Korean characters. These code standards use a
/// mixed 8-/16-bit encoding. This format is not commonly used today.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 2: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-2-high-byte-mapping-through-table)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 2](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format2 = fun (platform : Repr platform_id) => {
    /// The length of the subtable in bytes
    length <- u16be,
    /// The language ID of the subtable
    language <- cmap_language_id platform,
    /// Array that maps high bytes to subHeaders: value is subHeader index × 8.
    sub_header_keys <- array16 256 u16be,
    // TODO: These probably need length limiting formats
    // https://github.com/yeslogic/fathom/pull/310
    // /// Variable-length array of SubHeader records.
    // sub_headers[ ]  <- SubHeader,
    // /// Variable-length array containing subarrays used for mapping the low byte of 2-byte characters.
    // glyph_id_array[ ]  <- u16be,
};

/// # Format 4: Segment mapping to delta values
///
/// This is the standard character-to-glyph-index mapping subtable for fonts that support only
/// Unicode Basic Multilingual Plane characters (U+0000 to U+FFFF).
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 4: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-4-segment-mapping-to-delta-values)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 4](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format4 = fun (platform : Repr platform_id) => {
    /// The length of the subtable in bytes
    length <- u16be,
    /// The language ID of the subtable
    language <- cmap_language_id platform,
    /// 2 × segCount.
    seg_count_x2 <- u16be,
    /// Number of contiguous ranges of character codes
    let seg_count = u16_div seg_count_x2 2,
    /// Maximum power of 2 less than or equal to segCount, times 2 ((2**floor(log₂(segCount))) * 2,
    /// where “**” is an exponentiation operator)
    search_range <- u16be,
    /// Log₂ of the maximum power of 2 less than or equal to numTables (log₂(searchRange/2), which
    /// is equal to floor(log₂(segCount)))
    entry_selector <- u16be,
    /// segCount times 2, minus searchRange ((segCount * 2) - searchRange)
    range_shift <- u16be,
    /// End characterCode for each segment, last=0xFFFF.
    end_code <- array16 seg_count u16be,
    /// Set to 0.
    _reserved_pad <- reserved s16be 0,
    /// Start character code for each segment.
    start_code <- array16 seg_count u16be,
    /// Delta for all character codes in segment.
    id_delta <- array16 seg_count s16be,
    /// Offsets into glyphIdArray or 0
    id_range_offsets <- array16 seg_count u16be,
    // TODO: Needs length limiting formats
    // /// Glyph index array (arbitrary length)
    // glyph_id_array[ ]  <- u16be,
};

/// # Format 6: Trimmed table mapping
///
/// Format 6 was designed to map 16-bit characters to glyph indexes when the character codes for a
/// font fall into a single contiguous range.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 6: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-6-trimmed-table-mapping)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 6](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format6 = fun (platform : Repr platform_id) => {
    /// The length of the subtable in bytes
    length <- u16be,
    /// The language ID of the subtable
    language <- cmap_language_id platform,
    /// First character code of subrange.
    first_code <- u16be,
    /// Number of character codes in subrange.
    entry_count <- u16be,
    /// Array of glyph index values for character codes in the range.
    glyph_id_array <- array16 entry_count u16be,
};

/// # Format 8: mixed 16-bit and 32-bit coverage
///
/// Subtable format 8 was designed to support Unicode supplementary-plane characters in UTF-16
/// encoding, though it is not commonly used. Format 8 is similar to format 2, in that it provides
/// for mixed-length character codes. Instead of allowing for 8- and 16-bit character codes,
/// however, it allows for 16- and 32-bit character codes.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 8: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-8-mixed-16-bit-and-32-bit-coverage)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 8](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format8 = fun (platform : Repr platform_id) => {
    /// Set to 0.
    _reserved <- reserved u16be 0,
    /// The length of the subtable in bytes (including the header)
    length <- u32be,
    /// The language ID of the subtable
    language <- cmap_language_id32 platform,
    /// Tightly packed array of bits (8K bytes total) indicating whether the particular 16-bit
    /// (index) value is the start of a 32-bit character code
    is32 <- array16 8192 u8,
    /// Number of groupings which follow
    num_groups <- u32be,
    /// Array of SequentialMapGroup records.
    groups <- array32 num_groups sequential_map_group,
};

/// # Format 10: Trimmed table mapping
///
/// Subtable format 10 was designed to support Unicode supplementary-plane characters, though it is
/// not commonly used. Format 10 is similar to format 6, in that it defines a trimmed array for a
/// tight range of character codes. It differs, however, in that is uses 32-bit character codes.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 10: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-10-trimmed-array)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 10](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format10 = fun (platform : Repr platform_id) => {
    /// Set to 0.
    _reserved <- reserved u16be 0,
    /// The length of the subtable in bytes (including the header)
    length <- u32be,
    /// The language ID of the subtable
    language <- cmap_language_id32 platform,
    /// First character code covered
    start_char_code <- u32be,
    /// Number of character codes covered
    num_chars <- u32be,
    /// Array of glyph indices for the character codes covered
    glyph_id_array <- array32 num_chars u16be,
};

/// # Format 12: Segmented coverage
///
/// This is the standard character-to-glyph-index mapping subtable for fonts supporting Unicode
/// character repertoires that include supplementary-plane characters (U+10000 to U+10FFFF).
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 12: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-12-segmented-coverage)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 12](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format12 = fun (platform : Repr platform_id) => {
    /// Set to 0.
    _reserved <- reserved u16be 0,
    /// The length of the subtable in bytes (including the header)
    length <- u32be,
    /// The language ID of the subtable
    language <- cmap_language_id32 platform,
    /// Number of groupings which follow
    num_groups <- u32be,
    /// Array of SequentialMapGroup records.
    groups <- array32 num_groups sequential_map_group,
};

/// # Format 13: Many-to-one range mappings
///
/// This subtable provides for situations in which the same glyph is used for hundreds or even
/// thousands of consecutive characters spanning across multiple ranges of the code space. This
/// subtable format may be useful for “last resort” fonts, although these fonts may use other
/// suitable subtable formats as well.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 13: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-13-many-to-one-range-mappings)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 13](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format13 = fun (platform : Repr platform_id) => {
    /// Set to 0.
    _reserved <- reserved u16be 0,
    /// The length of the subtable in bytes (including the header)
    length <- u32be,
    /// The language ID of the subtable
    language <- cmap_language_id32 platform,
    /// Number of groupings which follow
    num_groups <- u32be,
    /// Array of ConstantMapGroup records.
    groups <- array32 num_groups constant_map_group,
};

/// # Format 14: Unicode Variation Sequences
///
/// Subtable format 14 specifies the Unicode Variation Sequences (UVSes) supported by the font. A
/// Variation Sequence, according to the Unicode Standard, comprises a base character followed by a
/// variation selector. For example, <U+82A6, U+E0101>.
///
/// This subtable format must only be used under platform ID 0 and encoding ID 5.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Format 14: Segment mapping to delta values](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#format-14-unicode-variation-sequences)
/// - [Apple's TrueType Reference Manual: `'cmap'` format 14](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_subtable_format14 = fun (platform : Repr platform_id) => fun (table_start : Pos) => {
    /// The length of the subtable in bytes (including the header)
    length <- u32be,
    /// Number of variation Selector Records
    num_var_selector_records <- u32be,
    /// Array of VariationSelector records.
    var_selector <- array32 num_var_selector_records (variation_selector table_start),
};

/// # Character Mapping subtable
let cmap_subtable = fun (platform : Repr platform_id) => {
    /// The start of the character mapping sub-table
    table_start <- stream_pos,
    /// Format number of the subtable
    format <- u16be,
    data <- match format {
        0 => cmap_subtable_format0 platform,
        2 => cmap_subtable_format2 platform,
        4 => cmap_subtable_format4 platform,
        6 => cmap_subtable_format6 platform,
        8 => cmap_subtable_format8 platform,
        10 => cmap_subtable_format10 platform,
        12 => cmap_subtable_format12 platform,
        13 => cmap_subtable_format13 platform,
        14 => cmap_subtable_format14 platform table_start,
        _ => unknown_table,
    },
};


/// # Encoding record
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Encoding records and encodings](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#encoding-records-and-encodings)
let encoding_record = fun (table_start : Pos) => {
    /// Platform identifier
    platform <- platform_id,
    /// Platform-specific encoding identifier
    encoding <- encoding_id platform,
    /// Byte offset to the subtable data
    subtable_offset <- offset32 table_start (cmap_subtable platform),
};

/// # Character Mapping Table (`cmap`)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: 'cmap' Header](https://docs.microsoft.com/en-us/typography/opentype/spec/cmap#cmap-header)
/// - [Apple's TrueType Reference Manual: The `'cmap'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html)
let cmap_table = {
    /// The start of the character mapping table
    table_start <- stream_pos,
    /// The version of the character
    version <- u16be,
    /// The number of encoding tables that follow
    num_tables <- u16be,
    /// An array of encoding records in the character mapping table
    encoding_records <- array16 num_tables (encoding_record table_start),
};


// -----------------------------------------------------------------------------

// # General Font Information
//
// Global information about the font.
//
// ## References
//
// - [Microsoft's OpenType Spec: head — Font Header Table](https://docs.microsoft.com/en-us/typography/opentype/spec/head)
// - [Apple's TrueType Reference Manual: The `'head'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6head.html)

/// # Font Header Table (`head`)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: head — Font Header Table](https://docs.microsoft.com/en-us/typography/opentype/spec/head)
/// - [Apple's TrueType Reference Manual: The `'head'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6head.html)
let head_table = {
    /// Major version number of the font header table.
    major_version <- u16be where u16_eq major_version 1,
    /// Minor version number of the font header table.
    minor_version <- u16be, // TODO: where minor_version == 0
    /// Set by the font manufacturer.
    ///
    /// This field exists for legacy reasons - Windows ignores this, instead
    /// using the version string (ID 5) in the `name` table.
    font_revision <- fixed,
    // TODO: document computation of checksum adjustment
    checksum_adjustment <- u32be,
    /// [Magic number](https://en.wikipedia.org/wiki/File_format#Magic_number), always set to
    /// 0x5F0F3CF5
    magic_number <- u32be where u32_eq magic_number 0x5F0F3CF5,
    /// General font flags.
    ///
    // TODO: Document flags
    flags <- u16be,  // TODO: bit patterns?
    /// The granularity of the font's coordinate grid.
    units_per_em <- u16be where bool_and (u16_gte units_per_em 16) (u16_lte units_per_em 16384),
    /// The date when the font was created.
    created <- long_date_time,
    /// The date when the font was modified.
    modified <- long_date_time,
    /// Describes a bounding box that contains all glyphs in the font.
    ///
    /// Glyphs that do not contain contours should be ignored when computing
    /// these values.
    glyph_extents <- {
        /// Minimum x coordinate.
        x_min <- s16be,
        /// Minimum y coordinate.
        y_min <- s16be,
        /// Maximum x coordinate.
        x_max <- s16be,
        /// Maximum y coordinate.
        y_max <- s16be,
    },
    /// Style flags.
    ///
    /// This should agree with the `fs_selection` bits in the `OS/2` table.
    /// Note that this is ignored on Windows.
    ///
    /// | Bit   | Meaning               |
    /// | ----- | --------------------- |
    /// | 0     | bold                  |
    /// | 1     | italic                |
    /// | 2     | underline             |
    /// | 3     | outline               |
    /// | 4     | shadow                |
    /// | 5     | condensed (narrow)    |
    /// | 6     | extended              |
    /// | 7-15  | reserved (Set to `0`) |
    mac_style <- u16be, // TODO: bit patterns?
    /// Smallest readable size in pixels
    lowest_rec_ppem <- u16be,
    /// Glyph direction hint. Deprecated (set to `2`).
    ///
    /// | Value | Meaning                               |
    /// | ----- | ------------------------------------- |
    /// | `0`   | mixed directional glyphs              |
    /// | `1`   | only strongly left to right glyphs    |
    /// | `2`   | like `1` but also contains neutrals   |
    /// | `-1`  | only strongly right to left glyphs    |
    /// | `-2`  | like `-1` but also contains neutrals  |
    font_direction_hint <- deprecated s16be 2, // TODO: use an enum format?
    /// The type of offsets to use when mapping glyph indices to offsets in the
    /// file (see the `loca_table` table).
    ///
    /// | Value | Meaning                       |
    /// | ----- | ----------------------------- |
    /// | `0`   | short offsets (`offset16`)    |
    /// | `1`   | long offsets (`offset32`)     |
    index_to_loc_format <- s16be, // TODO: use an enum format?
    /// The format to use for glyph data.
    ///
    /// | Value | Meaning                       |
    /// | ----- | ----------------------------- |
    /// | `0`   | current format                |
    glyph_data_format <- s16be, // NOTE: Currently unused?
};


// -----------------------------------------------------------------------------

// # Horizontal Layout Information
//
// Information related to fonts whose characters are written horizontally
// (either right-to-left or left-to-right).
//
// ## References
//
// - [Microsoft's OpenType Spec: hhea — Horizontal Header Table](https://docs.microsoft.com/en-us/typography/opentype/spec/hhea)
// - [Apple's TrueType Reference Manual: The `'hhea'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hhea.html)

/// # Horizontal Header Table (`hhea`)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: hhea — Horizontal Header Table](https://docs.microsoft.com/en-us/typography/opentype/spec/hhea)
/// - [Apple's TrueType Reference Manual: The `'hhea'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hhea.html)
let hhea_table = {
    /// Major version number of the horizontal header table.
    major_version <- u16be where u16_eq major_version 1,
    /// Minor version number of the horizontal header table.
    minor_version <- u16be, // TODO: where minor_version == 0
    /// Distance from the baseline to the highest ascender.
    ascent <- fword,
    /// Distance from the baseline to the lowest descender.
    descent <- fword,
    /// The intended gap between baselines.
    line_gap <- fword,
    /// Must be consistent with horizontal metrics.
    advance_width_max <- ufword,
    /// Must be consistent with horizontal metrics.
    min_left_side_bearing <- fword,
    /// Must be consistent with horizontal metrics.
    min_right_side_bearing <- fword,
    /// `max(left_side_bearing + (x_max - x_min))`
    x_max_extent <- fword,
    /// Used to calculate the slope of the caret (rise/run).
    caret_slope <- {
        /// Set to `1` for vertical caret.
        rise <- s16be,
        /// Set to `0` for vertical caret.
        run <- s16be,
    },
    /// Set to `0` for non-slanted fonts
    caret_offset <- s16be,

    _reserved0 <- reserved s16be 0, // TODO: allow `_` as label
    _reserved1 <- reserved s16be 0, // TODO: allow `_` as label
    _reserved2 <- reserved s16be 0, // TODO: allow `_` as label
    _reserved3 <- reserved s16be 0, // TODO: allow `_` as label

    /// Set to `0` for current format.
    metric_data_format <- s16be,
    /// Number of `long_horizontal_metric` records in the in the `htmx_table`.
    number_of_long_horizontal_metrics <- u16be,
};


// -----------------------------------------------------------------------------

// # Horizontal Metrics
//
// Information about the metrics used for horizontal layout for each of the
// glyphs in the font.
//
// ## References
//
// - [Microsoft's OpenType Spec: hmtx — Horizontal Metrics Table](https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx)
// - [Apple's TrueType Reference Manual: The `'hmtx'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hmtx.html)

/// Horizontal metrics that provide an `advance_width`.
let long_horizontal_metric = {
    /// Advance width, in font design units.
    advance_width <- u16be,
    /// Glyph left side bearing, in font design units.
    left_side_bearing <- s16be
};

/// # Horizontal Metrics Table (`hmtx`)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: hmtx — Horizontal Metrics Table](https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx)
/// - [Apple's TrueType Reference Manual: The `'hmtx'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hmtx.html)
let htmx_table = fun (number_of_long_horizontal_metrics : U16) => fun (num_glyphs : U16) => {
    /// Long horizontal metrics, indexed by the glyph ID.
    h_metrics <- array16 number_of_long_horizontal_metrics long_horizontal_metric,
    /// Left side bearings for glyph IDs greater than or equal to the
    /// `number_of_long_horizontal_metrics`.
    left_side_bearings <- array16 (u16_sub num_glyphs number_of_long_horizontal_metrics) s16be,
};


// -----------------------------------------------------------------------------

// # Maximium Profile
//
// Information about the memory requirements of a font.
//
// ## References
//
// - [Microsoft's OpenType Spec: maxp — Maximum Profile](https://docs.microsoft.com/en-us/typography/opentype/spec/maxp)
// - [Apple's TrueType Reference Manual: The `'maxp'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6maxp.html)

/// Fields specific to maxp version 1.0
let maxp_version_1 = {
    /// Maximum points in non-composite glyphs.
    max_points <- u16be,
    /// Maximum contours in non-composite glyphs.
    max_contours <- u16be,
    /// Maximum points in composite glyphs.
    max_composite_points <- u16be,
    /// Maximum contours in composite glyphs.
    max_composite_contours <- u16be,
    /// Should be set to `2` in most cases.
    ///
    /// | Value | Meaning                                           |
    /// | ----- | ------------------------------------------------- |
    /// | `1`   | instructions do not use the twilight zone (Z0)    |
    /// | `2`   | instructions do use Z0                            |
    max_zones <- u16be,
    /// Maximum points used in in the twilight zone (Z0).
    max_twilight_points <- u16be,
    /// Number of Storage Area locations.
    max_storage <- u16be,
    /// Number of function definitions (FDEFs).
    max_function_defs <- u16be,
    /// Number of instruction definitions (IDEFs).
    max_instruction_defs <- u16be,
    /// Maximum stack depth across the Font Program ('fpgm' table), the
    /// Control Value Program ('prep' table), and all glyph instructions
    /// (in the 'glyf' table)
    max_stack_elements <- u16be,
    /// Maximum size in bytes used for all glyph instructions.
    max_size_of_instructions <- u16be,
    /// Maximum number of components referenced at “top level” of all
    /// composite glyphs.
    max_component_elements <- u16be,
    /// Maximum levels of recursion used when constructing compound glyphs.
    ///
    /// | Value | Meaning                                           |
    /// | ----- | ------------------------------------------------- |
    /// | `0`   | the font only contains simple glyphs              |
    /// | `1`   | compound glyphs only contain simple glyphs (there are no components within components) |
    max_component_depth <- u16be where u16_lte max_component_depth 16,
};


/// # Maximium Profile Table (`maxp`)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: maxp — Maximum Profile](https://docs.microsoft.com/en-us/typography/opentype/spec/maxp)
/// - [Apple's TrueType Reference Manual: The `'maxp'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6maxp.html)
let maxp_table = {
    /// The version of the table
    version <- version16dot16,
    /// The number of glyphs in the font.
    ///
    /// Both versions currently defined (0.5 and 1.0) start with num_glyphs.
    num_glyphs <- u16be,
    /// Version specific data.
    data <- match version {
        0x00010000 => maxp_version_1,
        _ => unknown_table,
    },
};


// -----------------------------------------------------------------------------

// # Name storage
//
// Multilingual name storage for OpenType fonts.
//
// This describes the storage of string data for use in other areas of OpenType
// fonts, for example in font names, family names, style names, descriptions,
// etc.
//
// ## References
//
// - [Microsoft's OpenType Spec: name — Naming Table](https://docs.microsoft.com/en-us/typography/opentype/spec/name)
// - [Apple's TrueType Reference Manual: The `'name'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html)

/// Name record
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Name records](https://docs.microsoft.com/en-us/typography/opentype/spec/name#name-records)
/// - [Apple's TrueType Reference Manual: The `'name'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html)
let name_record = fun (storage_start : Pos) => {
    /// Platform identifier
    platform <- platform_id,
    /// Platform-specific encoding identifier
    encoding <- encoding_id platform,
    /// Language identifier
    language <- language_id,
    /// Name identifier
    ///
    /// | Value         | Meaning                               |
    /// | ------------- | ------------------------------------- |
    /// | `0`           | copyright notice                      |
    /// | `1`           | font family name                      |
    /// | `2`           | font subfamily name                   |
    /// | `3`           | unique font identification            |
    /// | `4`           | full font name                        |
    /// | `5`           | version string                        |
    /// | `6`           | PostScript name                       |
    /// | `7`           | trademark notice                      |
    /// | `8`           | manufacturer name                     |
    /// | `9`           | typeface designer name                |
    /// | `10`          | typeface description                  |
    /// | `11`          | font vendor url                       |
    /// | `12`          | font designer url                     |
    /// | `13`          | license description                   |
    /// | `14`          | license info url                      |
    /// | `15`          | reserved                              |
    /// | `16`          | typographic family name               |
    /// | `17`          | typographic subfamily name            |
    /// | `18`          | compatible full name                  |
    /// | `19`          | sample text                           |
    /// | `20`          | PostScript font name                  |
    /// | `21`          | WWS family name                       |
    /// | `22`          | WWS subfamily name                    |
    /// | `23`          | light background palette              |
    /// | `24`          | dark background palette               |
    /// | `25`          | variations PostScript name prefix     |
    /// | `26..<256`    | reserved                              |
    /// | `256..<32768` | font-specific names                   |
    name_id <- u16be,
    /// String length
    length <- u16be,
    /// Offset to the string data, relative to the start of the storage area
    offset <- offset16 storage_start (array16 length u8),
};

/// # Language tag record
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Naming table header](https://docs.microsoft.com/en-us/typography/opentype/spec/name#naming-table-header)
/// - [Apple's TrueType Reference Manual: The `'name'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html)
let lang_tag_record = fun (storage_start : Pos) => {
    /// Language tag string length
    length <- u16be,
    /// Offset to the language tag string data
    offset <- offset16 storage_start (array16 length u8),
};

let name_version_1 = fun (storage_start : Pos) => {
    /// The number of language tags to expect
    lang_tag_count <- u16be,
    /// The array of language tag records
    lang_tag_records <- array16 lang_tag_count (lang_tag_record storage_start),
};

/// # Naming table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Naming table header](https://docs.microsoft.com/en-us/typography/opentype/spec/name#naming-table-header)
/// - [Apple's TrueType Reference Manual: The `'name'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html)
let name_table = {
    /// The start of the naming table
    table_start <- stream_pos,

    /// Table version
    version <- u16be,
    /// The number of `name_records` to expect
    name_count <- u16be,
    /// The offset to the string storage area, relative to the start of the naming table.
    storage_offset <- u16be,
    /// The array of name records
    name_records <- array16 name_count (name_record (pos_add_u16 table_start storage_offset)),

    /// Version specific data
    data <- match version {
        0 => {},
        1 => name_version_1 (pos_add_u16 table_start storage_offset),
        _ => unknown_table,
    },
};

/// # Index to location table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: `loca` table](https://docs.microsoft.com/en-us/typography/opentype/spec/loca)
/// - [Apple's TrueType Reference Manual: The `'loca'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6loca.html)
let loca_table = fun (num_glyphs : U16) => fun (index_to_loc_format : S16) => {
    offsets <- match index_to_loc_format {
        // short offsets
        0 => array16 (u16_add num_glyphs 1) u16be, // TODO Offset16
        // long offsets
        1 => array16 (u16_add num_glyphs 1) u32be, // TODO Offset32
        _ => unknown_table
    }
};

/// # Glyph Header
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Headers](https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#glyph-headers)
/// - [Apple's TrueType Reference Manual: The `'loca'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html)
let glyph_header = {
    /// If the number of contours is greater than or equal to zero, this is a simple glyph. If
    /// negative, this is a composite glyph — the value -1 should be used for composite glyphs.
    number_of_contours <- s16be,
    /// Minimum x for coordinate data.
    x_min <- s16be,
    /// Minimum y for coordinate data.
    y_min <- s16be,
    /// Maximum x for coordinate data.
    x_max <- s16be,
    /// Maximum y for coordinate data.
    y_max <- s16be,
};

/// # Simple glyph description
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Headers](https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#simple-glyph-description)
/// - [Apple's TrueType Reference Manual: The `'loca'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html)
let simple_glyph = fun (number_of_contours : U16) => {
    /// Array of point indices for the last point of each contour, in increasing numeric order.
    end_pts_of_contours <- array16 number_of_contours u16be,
    /// Total number of bytes for instructions. If instructionLength is zero, no instructions are
    /// present for this glyph, and this field is followed directly by the flags field.
    instruction_length <- u16be,
    /// Array of instruction byte code for the glyph.
    instructions <- array16 instruction_length u8,
    /// Array of flag elements.
    // flags[variable] <- uint8,
    /// xCoordinates[variable] 	Contour point x-coordinates. Coordinate for the first point is relative to (0,0);
    /// others are relative to previous point.
    // or int16 <- uint8,
    /// yCoordinates[variable] 	Contour point y-coordinates. Coordinate for the first point is relative to (0,0);
    /// others are relative to previous point.
    // or int16 <- uint8,
};

let args_are_signed = fun (flags : U16) =>
    (u16_neq (u16_and flags 0x0002) 0);

let arg_format = fun (flags : U16) =>
    match (u16_neq (u16_and flags 0x0001) 0) {
        // If the bit is set the arguments are 16-bit
        true => match (args_are_signed flags) {
            true => s16be,
            false => u16be,
        },
        // Otherwise they are 8-bit
        false => match (args_are_signed flags) {
            true => s8,
            false => u8,
        },
    };

/// # Composite glyph description
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Headers](https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description)
/// - [Apple's TrueType Reference Manual: The `'loca'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html)
let composite_glyph = {
    /// component flag
    flags <- u16be,
    /// glyph index of component
    glyphIndex <- u16be,
    /// x-offset for component or point number; type depends on bits 0 and 1 in component flags
    argument1 <- arg_format flags,
    /// y-offset for component or point number; type depends on bits 0 and 1 in component flags
    argument2 <- arg_format flags,
};

/// # TrueType glyph
let glyph = {
    header <- glyph_header,
    data <- match (s16_lt header.number_of_contours 0) {
        true => composite_glyph,
        false => simple_glyph (s16_unsigned_abs header.number_of_contours),
    }
};

/// # Glyph data table (TrueType)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/glyf)
/// - [Apple's TrueType Reference Manual: The `'glyf'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html)
let glyf_table = fun (num_glyphs : U16) => {
    glyphs <- array16 num_glyphs glyph,
};

// -----------------------------------------------------------------------------

/// # OS/2 Version 0
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#version-0)
/// - [Apple's TrueType Reference Manual: The `'OS/2'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6OS2.html)
let os2_version_0 = {
    s_typo_ascender <- s16be,
    s_typo_descender <- s16be,
    s_typo_line_gap <- s16be,
    us_win_ascent <- u16be,
    usWinDescent <- u16be,
};

/// # OS/2 Version 1
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#version-1)
/// - [Apple's TrueType Reference Manual: The `'OS/2'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6OS2.html)
let os2_version_1 = {
    version_0 <- os2_version_0,
    ul_code_page_range1 <- u32be,
    ul_code_page_range2 <- u32be,
};

/// # OS/2 Version 2, 3, 4
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#version-2)
/// - [Apple's TrueType Reference Manual: The `'OS/2'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6OS2.html)
let os2_version_2_3_4 = {
    version_1 <- os2_version_1,
    sx_height <- s16be,
    s_cap_height <- s16be,
    us_default_char <- u16be,
    us_break_char <- u16be,
    us_max_context <- u16be,
};

/// # OS/2 Version 5
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#version-0)
/// - [Apple's TrueType Reference Manual: The `'OS/2'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6OS2.html)
let os2_version_5 = {
    parent <- os2_version_2_3_4,
    usLowerOpticalPointSize <- u16be,
    usUpperOpticalPointSize <- u16be,
};

/// # OS/2 and Windows Metrics Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/os2)
/// - [Apple's TrueType Reference Manual: The `'OS/2'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6OS2.html)
let os2_table = fun (table_length : U32) => {
    version <- u16be,
    x_avg_char_width <- s16be,
    us_weight_class <- u16be,
    us_width_class <- u16be,
    fs_type <- u16be,
    y_subscript_x_size <- s16be,
    y_subscript_y_size <- s16be,
    y_subscript_x_offset <- s16be,
    y_subscript_y_offset <- s16be,
    y_superscript_x_size <- s16be,
    y_superscript_y_size <- s16be,
    y_superscript_x_offset <- s16be,
    y_superscript_y_offset <- s16be,
    y_strikeout_size <- s16be,
    y_strikeout_position <- s16be,
    s_family_class <- s16be,
    panose <- array8 10 u8,
    ul_unicode_range1 <- u32be,
    ul_unicode_range2 <- u32be,
    ul_unicode_range3 <- u32be,
    ul_unicode_range4 <- u32be,
    ach_vend_id <- tag,
    fs_selection <- u16be,
    us_first_char_index <- u16be,
    us_last_char_index <- u16be,
    data <- match version {
        // Note: Documentation for OS/2 version 0 in Apple’s TrueType Reference Manual stops at the
        // usLastCharIndex field and does not include the last five fields of the table as it was
        // defined by Microsoft. Some legacy TrueType fonts may have been built with a shortened
        // version 0 OS/2 table. Applications should check the table length for a version 0 OS/2
        // table before reading these fields.
        0 => match (u32_gte table_length 78) {
            true => os2_version_0,
            false => {},
        },
        1 => os2_version_1,
        2 => os2_version_2_3_4,
        3 => os2_version_2_3_4,
        4 => os2_version_2_3_4,
        5 => os2_version_5,
        // The previous OS/2 versions are all additive. So if we encounter a newer version try
        // reading it as the newest one we know about.
        _ => os2_version_5,
    }
};

// -----------------------------------------------------------------------------



/// # PostScript Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Data](https://docs.microsoft.com/en-us/typography/opentype/spec/post)
/// - [Apple's TrueType Reference Manual: The `'post'` table](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6post.html)
let post_table = {
    /// 0x00010000 for version 1.0 0x00020000 for version 2.0
    /// 0x00025000 for version 2.5 (deprecated) 0x00030000 for version 3.0
    version <- version16dot16,
    /// Italic angle in counter-clockwise degrees from the vertical. Zero for upright text,
    /// negative for text that leans to the right (forward).
    italic_angle <- fixed,
    /// This is the suggested distance of the top of the underline from the baseline (negative
    /// values indicate below baseline). The PostScript definition of this FontInfo dictionary key
    /// (the y coordinate of the center of the stroke) is not used for historical reasons. The
    /// value of the PostScript key may be calculated by subtracting half the underlineThickness
    /// from the value of this field.
    underline_position <- fword,
    /// Suggested values for the underline thickness. In general, the underline thickness should
    /// match the thickness of the underscore character (U+005F LOW LINE), and should also match
    /// the strikeout thickness, which is specified in the OS/2 table.
    underline_thickness <- fword,
    /// Set to 0 if the font is proportionally spaced, non-zero if the font is not proportionally
    /// spaced (i.e. monospaced).
    is_fixed_pitch <- u32be,
    /// Minimum memory usage when an OpenType font is downloaded.
    min_mem_type42 <- u32be,
    /// Maximum memory usage when an OpenType font is downloaded.
    max_mem_type42 <- u32be,
    /// Minimum memory usage when an OpenType font is downloaded as a Type 1 font.
    min_mem_type1 <- u32be,
    /// Maximum memory usage when an OpenType font is downloaded as a Type 1 font.
    max_mem_type1 <- u32be,
    names <- match version {
        /// Version 1, standard Macintosh names
        0x00010000 => {},
        /// Version 2, non-stanard names stored in table as Pascal strings
        0x00020000 => {
            /// Number of glyphs (this should be the same as numGlyphs in 'maxp' table).
            num_glyphs <- u16be,
            /// Array of indices into the string data.
            glyph_name_index <- array16 num_glyphs u16be,
            /// Storage for the string data.
            string_data <- stream_pos,
        },
        /// Version 2.5 (deprecated), offset from standard Macintosh index
        0x00025000 => {
            /// Number of glyphs
            num_glyphs <- u16be,
            /// Difference between graphic index and standard order of glyph
            offset <- array16 num_glyphs s8,
        },
        /// Version 3, no glyph names stored in font
        ///
        /// This version is required for CFF fonts.
        0x00030000 => {},
        // Apple defines a version 4 but it's not part of OpenType and says it
        // should be avoided:
        // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6post.html
        _ => {},
    }
};


// -----------------------------------------------------------------------------

// TODO: "PCLT" .. "sbix" tables


// -----------------------------------------------------------------------------

// TODO: "BASE" table
//
// - [Microsoft's OpenType Spec: BASE — Baseline Table](https://docs.microsoft.com/en-us/typography/opentype/spec/base)

let base_table = unknown_table;


// -----------------------------------------------------------------------------

// TODO: "GDEF" table
//
// - [Microsoft's OpenType Spec: GDEF — Glyph Definition Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef)

/// # Attachment Point List table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Attachment Point List table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#attachment-point-list-table)
let attach_list = (
    /// AttachPoint table
    let attach_point_table = {
        /// Number of attachment points on this glyph
        point_count <- u16be,
        /// Array of contour point indices -in increasing numerical order
        point_indices <- array16 point_count u16be,
    };

    {
        /// The start of the AttachList table
        table_start <- stream_pos,
        /// Offset to Coverage table - from beginning of AttachList table
        coverage <- offset16 table_start coverage_table,
        /// Number of glyphs with attachment points
        glyph_count <- u16be,
        /// Array of offsets to AttachPoint tables-from beginning of AttachList table-in Coverage Index
        /// order
        attach_point_offsets <- array16 glyph_count (offset16 table_start attach_point_table),
    }
);

/// # Caret Value Tables
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Caret Value Tables](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caret-value-tables)
let caret_value = (
    /// # Caret Value Format 1
    ///
    /// ## References
    ///
    /// - [Microsoft's OpenType Spec: Caret Value Format 1](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-1)
    let caret_value_format_1 = {
        /// X or Y value, in design units
        coordinate <- s16be,
    };

    /// # CaretValue Format 2
    ///
    /// ## References
    ///
    /// - [Microsoft's OpenType Spec: Caret Value Format 2](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-2)
    let caret_value_format_2 = {
        /// Contour point index on glyph
        caret_value_point_index <- u16be,
    };

    /// # CaretValue Format 3
    ///
    /// ## References
    ///
    /// - [Microsoft's OpenType Spec: Caret Value Format 3](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#caretvalue-format-3)
    let caret_value_format_3 = fun (table_start : Pos) => {
        /// X or Y value, in design units
        coordinate <- s16be,
        /// Offset to Device table (non-variable font) / Variation Index table (variable font) for
        /// X or Y value-from beginning of CaretValue table
        table <- offset16 table_start device_or_variation_index_table,
    };

    {
        /// The start of the Caret Value table
        table_start <- stream_pos,
        /// Format identifier
        caret_value_format <- u16be,
        data <- match caret_value_format {
            1 => caret_value_format_1,
            2 => caret_value_format_2,
            3 => caret_value_format_3 table_start,
            _ => unknown_table,
        },
    }
);

/// # Ligature Glyph Table (LigGlyph)
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Ligature Glyph Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#ligature-glyph-table)
let lig_glyph = {
    /// The start of the LigGlyph table
    table_start <- stream_pos,
    /// Number of CaretValue tables for this ligature (components - 1)
    caret_count <- u16be,
    /// Array of offsets to CaretValue tables, from beginning of LigGlyph table — in increasing
    /// coordinate order
    caret_values <- array16 caret_count (offset16 table_start caret_value),
};

/// # Ligature Caret List Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Ligature Caret List Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#ligature-caret-list-table)
let lig_caret_list = {
    /// The start of the LigCaretList table
    table_start <- stream_pos,
    /// Offset to Coverage table - from beginning of LigCaretList table
    coverage <- offset16 table_start coverage_table,
    /// Number of ligature glyphs
    lig_glyph_count <- u16be,
    /// Array of offsets to LigGlyph tables, from beginning of LigCaretList table — in Coverage
    /// Index order
    lig_glyph_offsets <- array16 lig_glyph_count (offset16 table_start lig_glyph),
};

/// # Mark Glyph Sets table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Mark Glyph Sets Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef#mark-glyph-sets-table)
let mark_glyph_sets = {
    /// The start of the MarkGlyphSets table
    table_start <- stream_pos,
    /// Format identifier == 1
    format <- u16be,
    /// Number of mark glyph sets defined
    mark_glyph_set_count <- u16be,
    /// Array of offsets to mark glyph set coverage tables, from the start of the MarkGlyphSets
    /// table.
    coverage <- array16 mark_glyph_set_count (offset32 table_start coverage_table),
};

/// # GDEF — Glyph Definition Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Glyph Definition Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gdef)
let gdef_table = (
    let gdef_header_version_1_2 = fun (gdef_start : Pos) => {
        /// Offset to the table of mark glyph set definitions, from beginning of GDEF header (may be
        /// NULL)
        mark_glyph_sets_def <- offset16 gdef_start mark_glyph_sets,
    };

    let gdef_header_version_1_3 = fun (gdef_start : Pos) => {
        /// Offset to the Item Variation Store table, from beginning of GDEF header (may be NULL)
        // TODO: Implement [Item Variation Store](https://docs.microsoft.com/en-us/typography/opentype/spec/otvarcommonformats#item-variation-store)
        item_var_store <- u32be,
    };

    {
        /// The start of the `GDEF` table
        table_start <- stream_pos,
        /// Major version of the GDEF table, = 1
        major_version <- u16be where u16_eq major_version 1,
        /// Minor version of the GDEF table
        minor_version <- u16be,
        /// Class definition table for glyph type, from beginning of GDEF header (may be NULL)
        glyph_class_def <- offset16 table_start class_def,
        /// Attachment point list table, from beginning of GDEF header (may be NULL)
        attach_list <- offset16 table_start attach_list,
        /// Ligature caret list table, from beginning of GDEF header (may be NULL)
        lig_caret_list <- offset16 table_start lig_caret_list,
        /// Class definition table for mark attachment type, from beginning of GDEF header (may be
        /// NULL)
        mark_attach_class_def <- offset16 table_start class_def,
        /// Version > 1.0 specific data
        data <- match minor_version {
            // 1.0 fields are above, shared with later versions
            0 => {},
            // 1.1 is not defined in the spec
            1 => {},
            2 => gdef_header_version_1_2 table_start,
            3 => gdef_header_version_1_3 table_start,
            // read unknown later versions as the last version we know about
            _ => gdef_header_version_1_3 table_start,
        },
    }
);


// -----------------------------------------------------------------------------

/// Shared structure of GSUB and GPOS tables
let layout_table = fun (tag : U32) => {
    /// The start of the table
    table_start <- stream_pos,
    /// Major version of the table
    major_version <- u16be where u16_eq major_version 1,
    /// Minor version of the table
    minor_version <- u16be,
    /// ScriptList table
    script_list <- offset16 table_start script_list,
    /// FeatureList table
    feature_list <- offset16 table_start feature_list,
    /// LookupList table
    lookup_list <- offset16 table_start (lookup_list tag),
    // TODO: fields from GPOS/GSUB version 1.1 (variable fonts)
};

// TODO: "GPOS" table
//
// - [Microsoft's OpenType Spec: GPOS — Glyph Positioning Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gpos)

let gpos_table = layout_table "GPOS";


// -----------------------------------------------------------------------------

/// # GSUB — Glyph Substitution Table
///
/// ## References
///
/// - [Microsoft's OpenType Spec: GSUB — Glyph Substitution Table](https://docs.microsoft.com/en-us/typography/opentype/spec/gsub)
let gsub_table = layout_table "GSUB";


// -----------------------------------------------------------------------------

// TODO: "JSTF" table
//
// - [Microsoft's OpenType Spec: JSTF — Justification Table](https://docs.microsoft.com/en-us/typography/opentype/spec/jstf)

let jstf_table = unknown_table;


// -----------------------------------------------------------------------------

// TODO: "MATH" table
//
// - [Microsoft's OpenType Spec: MATH - The Mathematical Typesetting Table](https://docs.microsoft.com/en-us/typography/opentype/spec/math)

let math_table = unknown_table;


// -----------------------------------------------------------------------------

// TODO: "avar" .. "vmtx" tables


// -----------------------------------------------------------------------------

// # OpenType Top Level Organization
//
// Formats that form the top-level of an OpenType font file.
//
// ## References
//
// - [Microsoft's OpenType Spec: Organization of an OpenType Font](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#organization-of-an-opentype-font)
// - [Apple's TrueType Reference Manual: TrueType Font files](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Overview)


/// # Table Record
///
/// A record that stores an offset to another table in the font file.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Table Directory](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#table-directory)
/// - [Apple's TrueType Reference Manual: The Font Directory](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Directory)
let table_record = {
    /// Table identifier.
    table_id <- tag,
    /// CheckSum for this table.
    ///
    /// ## References
    ///
    /// - [Microsoft's OpenType Spec: Calculating Checksums](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#calculating-checksums)
    checksum <- u32be,
    /// Offset from the beginning of the TrueType font file.
    offset <- u32be,
    /// Length of this table.
    length <- u32be,
};

/// Find a table record using the given `table_id`.
let find_table =
    fun (num_tables : U16) =>
    fun (table_records : Array16 num_tables (Repr table_record)) =>
    fun (table_id : Repr tag) =>
        // TODO: accelerate using binary search
        // TODO: make use of `table_record.search_range`
        // TODO: make use of `table_record.entry_selector`
        // TODO: make use of `table_record.range_shift`
        array16_find _ (Repr table_record)
            (fun table_record => u32_eq table_record.table_id table_id)
            table_records;

/// Create a link to the given `table_format`.
let link_table =
    fun (file_start : Pos) =>
    fun (table_record : Repr table_record) =>
    fun (table_format : Format) =>
        // TODO: make use of `table_record.checksum`
        link (pos_add_u32 file_start table_record.offset)
            (limit32 table_record.length table_format);

/// # Table Directory
///
/// A directory of the top-level tables in the font.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Table Directory](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#table-directory)
/// - [Apple's TrueType Reference Manual: The Font Directory](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Directory)
let table_directory = fun (file_start : Pos) => {
    /// Version of the font.
    ///
    /// | Value         | Meaning                                   |
    /// | ------------- | ----------------------------------------- |
    /// | `0x00010000`  | for fonts containing TrueType outlines    |
    /// | `0x4F54544F`  | (`'OTTO'`) for fonts containing CFF data  |
    ///
    /// Apple allows 'true' and 'typ1', but this should not be found in OpenType files.
    sfnt_version <- u32be where
        bool_or (u32_eq sfnt_version 0x00010000) (u32_eq sfnt_version "OTTO"),

    /// Number of tables in the directory.
    num_tables <- u16be,
    /// For enabling quick binary searches.
    search_range <- u16be,       // TODO: (Maximum power of 2 <= num_tables) x 16
    /// For enabling quick binary searches.
    entry_selector <- u16be,     // TODO: Log2(maximum power of 2 <= num_tables)
    /// For enabling quick binary searches.
    range_shift <- u16be,        // TODO: NumTables x 16-searchRange

    /// An array of table records
    // FIXME: sorted in ascending order by tag
    table_records <- array16 num_tables table_record,

    /// Font table links
    ///
    /// ## References
    ///
    /// - [Microsoft's OpenType Spec: Font Tables](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#font-tables)
    /// - [Apple's TrueType Reference Manual: TrueType Font files](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Overview)
    table_links <- (
        let required_table =
            fun (table_id : Repr tag) =>
            fun (table_format : Format) => {
                // TODO: let formats
                table_record <- unwrap (Repr table_record) (find_table _ table_records table_id),
                link <- link_table file_start table_record table_format,
            };

        let required_table_with_len =
            fun (table_id : Repr tag) =>
            fun (table_format : (U32 -> Format)) => {
                // TODO: let formats
                table_record <- unwrap (Repr table_record) (find_table _ table_records table_id),
                link <- link_table file_start table_record (table_format table_record.length),
            };

        let optional_table =
            fun (table_id : Repr tag) =>
            fun (table_format : Format) =>
                option_fold (Repr table_record) Format {}
                    (fun record => link_table file_start record table_format)
                    (find_table _ table_records table_id);

        {
            // Required Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#required-tables
            cmap <- required_table "cmap" cmap_table,
            head <- required_table "head" head_table,
            hhea <- required_table "hhea" hhea_table,
            maxp <- required_table "maxp" maxp_table,
            htmx <- required_table "hmtx" {
                // TODO: let formats
                hhea <- deref _ hhea.link,
                maxp <- deref (limit32 maxp.table_record.length maxp_table) maxp.link,
                table <- htmx_table
                    hhea.number_of_long_horizontal_metrics
                    maxp.num_glyphs,
            },
            name <- required_table "name" name_table,
            os2 <- required_table_with_len "OS/2" os2_table,
            post <- required_table "post" post_table,

            // TrueType Outline Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-related-to-truetype-outlines
            cvt <- optional_table "cvt " unknown_table,
            fpgm <- optional_table "fpgm" unknown_table,
            glyf <- optional_table "glyf" {
                // TODO: let formats
                maxp <- deref (limit32 maxp.table_record.length maxp_table) maxp.link,
                table <- glyf_table 1,
                // TODO: use `loca` entries when parsing the glyphs
                // table <- glyf_table maxp.num_glyphs,
            },
            loca <- optional_table "loca" {
                // TODO: let formats
                maxp <- deref (limit32 maxp.table_record.length maxp_table) maxp.link,
                head <- deref _ head.link,
                table <- loca_table maxp.num_glyphs head.index_to_loc_format,
            },
            prep <- optional_table "prep" unknown_table,
            gasp <- optional_table "gasp" unknown_table,

            // CFF Outline Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-related-to-cff-outlines
            cff <- optional_table "CFF " unknown_table,
            cff2 <- optional_table "CFF2" unknown_table,
            vorg <- optional_table "VORG" unknown_table,

            // SVG Outline Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#table-related-to-svg-outlines
            svg <- optional_table "SVG " unknown_table,

            // Bitmap Glyph Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-related-to-bitmap-glyphs
            ebdt <- optional_table "EBDT" unknown_table,
            eblc <- optional_table "EBLC" unknown_table,
            ebsc <- optional_table "EBSC" unknown_table,

            // Color Bitmap Glyph Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-related-to-bitmap-glyphs
            cbdt <- optional_table "CBDT" unknown_table,
            cblc <- optional_table "CBLC" unknown_table,
            sbix <- optional_table "sbix" unknown_table,

            // Advanced Typographic Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#advanced-typographic-tables
            base <- optional_table "BASE" base_table,
            gdef <- optional_table "GDEF" gdef_table,
            gpos <- optional_table "GPOS" gpos_table,
            gsub <- optional_table "GSUB" gsub_table,
            jstf <- optional_table "JSTF" jstf_table,
            math <- optional_table "MATH" math_table,

            // OpenType Font Variation Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-used-for-opentype-font-variations
            avar <- optional_table "avar" unknown_table,
            cvar <- optional_table "cvar" unknown_table,
            fvar <- optional_table "fvar" unknown_table,
            gvar <- optional_table "gvar" unknown_table,
            hvar <- optional_table "HVAR" unknown_table,
            mvar <- optional_table "MVAR" unknown_table,
            stat <- optional_table "STAT" unknown_table,
            vvar <- optional_table "VVAR" unknown_table,

            // Color Font Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#tables-related-to-color-fonts
            colr <- optional_table "COLR" unknown_table,
            cpal <- optional_table "CPAL" unknown_table,

            // Other OpenType Tables
            //
            // https://docs.microsoft.com/en-us/typography/opentype/spec/otff#other-opentype-tables
            dsig <- optional_table "DSIG" unknown_table,
            hdmx <- optional_table "hdmx" unknown_table,
            kern <- optional_table "kern" unknown_table,
            ltsh <- optional_table "LTSH" unknown_table,
            merg <- optional_table "MERG" unknown_table,
            meta <- optional_table "meta" unknown_table,
            pclt <- optional_table "PCLT" unknown_table,
            vdmx <- optional_table "VDMX" unknown_table,
            vhea <- optional_table "vhea" unknown_table,
            vmtx <- optional_table "vmtx" unknown_table,
        }
    ),
};

/// # OpenType file
///
/// The main entrypoint of an OpenType font file.
///
/// ## References
///
/// - [Microsoft's OpenType Spec: Organization of an OpenType Font](https://docs.microsoft.com/en-us/typography/opentype/spec/otff#organization-of-an-opentype-font)
/// - [Apple's TrueType Reference Manual: TrueType Font files](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html#Overview)
let main = {
    /// The start of the font file.
    start <- stream_pos,
    /// The directory of tables in the font.
    directory <- table_directory start,
};


// -----------------------------------------------------------------------------

main
