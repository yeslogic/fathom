stdout = '''
let id : fun (A : Type) -> A -> A = fun A a => a;
let Eq : fun (A : Type) -> A -> A -> Type = fun A a0 a1 => fun (P : A ->
Type) -> P a0 -> P a1;
let refl : fun (A : Type) (a : A) (P : A -> Type) -> P a -> P a =
fun A a P => id (P a);
let fun_eta_left : fun (f : Type -> Type) (P : (Type -> Type) -> Type) -> P f ->
P (fun x => f x) = fun f => refl (Type -> Type) f;
let fun_eta_right : fun (f : Type -> Type) (P : (Type -> Type) -> Type) ->
P (fun x => f x) -> P f = fun f => refl (Type -> Type) f;
let fun_eta_left : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type) ->
Type) -> P f -> P (fun x => f x) = fun f => refl (Type -> Type -> Type) f;
let fun_eta_right : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type)
-> Type) -> P (fun x => f x) -> P f = fun f => refl (Type -> Type -> Type) f;
let fun_eta_left : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type) ->
Type) -> P f -> P (fun x y => f x y) = fun f => refl (Type -> Type -> Type) f;
let fun_eta_right : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type)
-> Type) -> P (fun x y => f x y) -> P f = fun f => refl (Type -> Type ->
Type) f;
let fun_eta_left : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type) ->
Type) -> P (fun x => f x) -> P (fun x y => f x y) = fun f => refl (Type -> Type
-> Type) f;
let fun_eta_right : fun (f : Type -> Type -> Type) (P : (Type -> Type -> Type)
-> Type) -> P (fun x y => f x y) -> P (fun x => f x) = fun f => refl (Type ->
Type -> Type) f;
let record_eta_left : fun (r : { x : Type, y : Type }) (P : {
    x : Type,
    y : Type,
} -> Type) -> P r -> P { x = r.x, y = r.y } = fun r => refl {
    x : Type,
    y : Type,
} r;
let record_eta_right : fun (r : { x : Type, y : Type }) (P : {
    x : Type,
    y : Type,
} -> Type) -> P { x = r.x, y = r.y } -> P r = fun r => refl {
    x : Type,
    y : Type,
} r;
let four_chars : fun (P : U32 -> Type) -> P "beng" -> P 1650814567 =
refl U32 "beng";
let three_chars : fun (P : U32 -> Type) -> P "BEN " -> P 1111838240 =
refl U32 "BEN ";
let foo : U32 -> U32 = fun x => match x { 1 => 0, x => x };
let eq_foo : fun (P : (U32 -> U32) -> Type) -> P (fun x => match x {
    1 => 0,
    x => x,
}) -> P (fun x => match x { 1 => 0, x => x }) = refl (U32 ->
U32) (fun a => match a { 1 => 0, x => x });
Type : Type
'''
stderr = ''
