use scoped_arena::Scope;
use std::cell::RefCell;

use crate::{StringId, StringInterner};
use crate::source::{ByteRange, FileId};
use crate::surface::{ExprField, FormatField, Item, Module, ParseMessage, Pattern, Term, TypeField, BinOp};
use crate::surface::lexer::{Error as LexerError, Token};

grammar<'arena, 'source>(
    interner: &RefCell<StringInterner>,
    scope: &'arena Scope<'arena>,
    messages: &mut Vec<ParseMessage>,
    file_id: FileId,
);

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token<'source> {
        "name" => Token::Name(<&'source str>),
        "hole" => Token::Hole(<&'source str>),
        "string literal" => Token::StringLiteral(<&'source str>),
        "number literal" => Token::NumberLiteral(<&'source str>),

        "def" => Token::KeywordDef,
        "fun" => Token::KeywordFun,
        "let" => Token::KeywordLet,
        "match" => Token::KeywordMatch,
        "overlap" => Token::KeywordOverlap,
        "Type" => Token::KeywordType,
        "true" => Token::KeywordTrue,
        "false" => Token::KeywordFalse,
        "where" => Token::KeywordWhere,

        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "." => Token::FullStop,
        "/" => Token::ForwardSlash,
        "->" => Token::HyphenGreater,
        "<-" => Token::LessHyphen,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "+" => Token::Plus,
        ";" => Token::Semicolon,
        "*" => Token::Star,
        "_" => Token::Underscore,

        "!=" => Token::BangEquals,
        "==" => Token::EqualsEquals,
        ">=" => Token::GreaterEquals,
        ">" => Token::Greater,
        "<=" => Token::LessEquals,
        "<" => Token::Less,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}

pub Module: Module<'arena, ByteRange> = {
    <items: Item*> => Module {
        items: scope.to_scope_from_iter(items.into_iter()),
    },
};

Item: Item<'arena, ByteRange> = {
    <start: @L> "def" <label: RangedName> <type_: (":" <LetTerm>)?> "=" <expr: Term> ";" <end: @R> => {
        Item::Definition {
            label,
            type_: type_.map(|type_| scope.to_scope(type_) as &_),
            expr: scope.to_scope(expr),
        }
    },
    <start: @L> <error: !> <end: @R> => {
        messages.push(ParseMessage::from_lalrpop_recovery(file_id, error));
        Item::ReportedError(ByteRange::new(file_id, start, end))
    },
};

Pattern: Pattern<ByteRange> = {
    <start: @L> <name: Name> <end: @R> => Pattern::Name(ByteRange::new(file_id, start, end), name),
    <start: @L> "_" <end: @R> => Pattern::Placeholder(ByteRange::new(file_id, start, end)),
    <start: @L> <string: StringLiteral> <end: @R> => Pattern::StringLiteral(ByteRange::new(file_id, start, end), string),
    <start: @L> <number: NumberLiteral> <end: @R> => Pattern::NumberLiteral(ByteRange::new(file_id, start, end), number),
    <start: @L> "true" <end: @R> => Pattern::BooleanLiteral(ByteRange::new(file_id, start, end), true),
    <start: @L> "false" <end: @R> => Pattern::BooleanLiteral(ByteRange::new(file_id, start, end), false),
};

AnnPattern: (Pattern<ByteRange>, Option<&'arena Term<'arena, ByteRange>>) = {
    <pattern: Pattern> => (pattern, None),
    "(" <pattern: Pattern> ":" <type_: LetTerm> ")" => (pattern, Some(scope.to_scope(type_))),
};

pub Term: Term<'arena, ByteRange> = {
    LetTerm,
    // FIXME: LALRPOP does not accept raw identifiers (see: https://github.com/lalrpop/lalrpop/issues/613)
    <start: @L> <expr: LetTerm> ":" <type_: LetTerm> <end: @R> => {
        Term::Ann(
            ByteRange::new(file_id, start, end),
            scope.to_scope(expr),
            scope.to_scope(type_),
        )
    },
};

LetTerm: Term<'arena, ByteRange> = {
    FunTerm,
    <start: @L> "let" <def_pattern: Pattern> <def_type: (":" <LetTerm>)?> "=" <def_expr: Term> ";" <body_expr: LetTerm> <end: @R> => {
        Term::Let(
            ByteRange::new(file_id, start, end),
            def_pattern,
            def_type.map(|def_type| scope.to_scope(def_type) as &_),
            scope.to_scope(def_expr),
            scope.to_scope(body_expr),
        )
    },
};

FunTerm: Term<'arena, ByteRange> = {
    EqExpr,
    <start: @L> <input_type: AppTerm> "->"  <output_type: FunTerm> <end: @R> => {
        Term::Arrow(
            ByteRange::new(file_id, start, end),
            scope.to_scope(input_type),
            scope.to_scope(output_type),
        )
    },
    <start: @L> "fun" <input_param: AnnPattern> "->"  <output_type: FunTerm> <end: @R> => {
        let (input_param, input_type) = input_param;
        Term::FunType(
            ByteRange::new(file_id, start, end),
            input_param,
            input_type,
            scope.to_scope(output_type),
        )
    },
    <start: @L> "fun" <input_param: AnnPattern> "=>" <output_type: LetTerm> <end: @R> => {
        let (input_param, input_type) = input_param;
        Term::FunLiteral(
            ByteRange::new(file_id, start, end),
            input_param,
            input_type,
            scope.to_scope(output_type),
        )
    },
};

EqExpr: Term<'arena, ByteRange> = {
    CmpExpr,
    BinExpr<CmpExpr, BinOpEq, EqExpr>,
    BinExpr<CmpExpr, BinOpNeq, EqExpr>,
};

CmpExpr: Term<'arena, ByteRange> = {
    AddExpr,
    BinExpr<AddExpr, BinOpLt, CmpExpr>,
    BinExpr<AddExpr, BinOpLte, CmpExpr>,
    BinExpr<AddExpr, BinOpGt, CmpExpr>,
    BinExpr<AddExpr, BinOpGte, CmpExpr>,
};

AddExpr: Term<'arena, ByteRange> = {
    MulExpr,
    BinExpr<MulExpr, BinOpAdd, AddExpr>,
    BinExpr<MulExpr, BinOpSub, AddExpr>,
};

MulExpr: Term<'arena, ByteRange> = {
    AppTerm,
    BinExpr<AppTerm, BinOpMul, MulExpr>,
    BinExpr<AppTerm, BinOpDiv, MulExpr>,
};

AppTerm: Term<'arena, ByteRange> = {
    AtomicTerm,
    <start: @L> <head_expr: AtomicTerm> <input_exprs: AtomicTerm+> <end: @R> => {
        Term::App(
            ByteRange::new(file_id, start, end),
            scope.to_scope(head_expr),
            scope.to_scope_from_iter(input_exprs),
        )
    },
};

AtomicTerm: Term<'arena, ByteRange> = {
    "(" <term: Term> ")" => term,

    <start: @L> <name: Name> <end: @R> => Term::Name(ByteRange::new(file_id, start, end), name),
    <start: @L> "_" <end: @R> => Term::Placeholder(ByteRange::new(file_id, start, end)),
    <start: @L> <name: Hole> <end: @R> => Term::Hole(ByteRange::new(file_id, start, end), name),
    <start: @L> "match" <scrutinee: AtomicTerm> "{"  <equations: Seq<(<Pattern> "=>" <Term>), ",">> "}" <end: @R> => {
        Term::Match(ByteRange::new(file_id, start, end), scope.to_scope(scrutinee), equations)
    },
    <start: @L> "Type" <end: @R> => Term::Universe(ByteRange::new(file_id, start, end)),
    <start: @L> <string: StringLiteral> <end: @R> => Term::StringLiteral(ByteRange::new(file_id, start, end), string),
    <start: @L> <number: NumberLiteral> <end: @R> => Term::NumberLiteral(ByteRange::new(file_id, start, end), number),
    <start: @L> "true" <end: @R> => Term::BooleanLiteral(ByteRange::new(file_id, start, end), true),
    <start: @L> "false" <end: @R> => Term::BooleanLiteral(ByteRange::new(file_id, start, end), false),
    <start: @L> "{" "}" <end: @R> => Term::UnitLiteral(ByteRange::new(file_id, start, end)),
    <start: @L> "{" <fields: NonEmptySeq<TypeField, ",">> "}" <end: @R> => {
        Term::RecordType(ByteRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <fields: NonEmptySeq<ExprField, ",">> "}" <end: @R> => {
        Term::RecordLiteral(ByteRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <fields: NonEmptySeq<FormatField, ",">> "}" <end: @R> => {
        Term::FormatRecord(ByteRange::new(file_id, start, end), fields)
    },
    <start: @L> "{" <name: RangedName> "<-" <format:Term> "|" <cond:Term> "}" <end: @R> => {
        Term::FormatCond(ByteRange::new(file_id, start, end), name, scope.to_scope(format), scope.to_scope(cond))
    },
    <start: @L> "overlap" "{" <fields: NonEmptySeq<FormatField, ",">> "}" <end: @R> => {
        Term::FormatOverlap(ByteRange::new(file_id, start, end), fields)
    },
    <start: @L> <head_expr: AtomicTerm> "." <label: RangedName> <end: @R> => {
        Term::Proj(ByteRange::new(file_id, start, end), scope.to_scope(head_expr), label)
    },
    <start: @L> "[" <exprs: Seq<Term, ",">> "]" <end: @R> => {
        Term::ArrayLiteral(ByteRange::new(file_id, start, end), exprs)
    },
    <start: @L> <error: !> <end: @R> => {
        messages.push(ParseMessage::from_lalrpop_recovery(file_id, error));
        Term::ReportedError(ByteRange::new(file_id, start, end))
    },
};

FormatField: FormatField<'arena, ByteRange> = {
    <label: RangedName> "<-" <format: Term> <pred: ("where" <Term>)?> => {
        FormatField::Format { label, format, pred }
    },
    "let" <label: RangedName> <type_: (":" <Term>)?> "=" <expr: Term> => {
        FormatField::Computed { label, type_, expr }
    },
};

TypeField: TypeField<'arena, ByteRange> = {
    <label: RangedName> ":" <type_: Term> => TypeField { label, type_ },
};

ExprField: ExprField<'arena, ByteRange> = {
    <label: RangedName> "=" <expr: Term> => ExprField { label, expr },
};

BinExpr<Lhs, Op, Rhs>: Term<'arena, ByteRange> = {
    <start: @L> <lhs: Lhs> <op: Op> <rhs: Rhs> <end: @R> => {
        Term::BinOp(
            ByteRange::new(file_id, start, end),
            scope.to_scope(lhs),
            op,
            scope.to_scope(rhs),
        )
    },
};

BinOpAdd: BinOp<ByteRange> = <start: @L> "+" <end: @R> => BinOp::Add(ByteRange::new(file_id, start, end));
BinOpSub: BinOp<ByteRange> = <start: @L> "-" <end: @R> => BinOp::Sub(ByteRange::new(file_id, start, end));
BinOpMul: BinOp<ByteRange> = <start: @L> "*" <end: @R> => BinOp::Mul(ByteRange::new(file_id, start, end));
BinOpDiv: BinOp<ByteRange> = <start: @L> "/" <end: @R> => BinOp::Div(ByteRange::new(file_id, start, end));

BinOpEq: BinOp<ByteRange> = <start: @L> "==" <end: @R> => BinOp::Eq(ByteRange::new(file_id, start, end));
BinOpNeq: BinOp<ByteRange> = <start: @L> "!=" <end: @R> => BinOp::Neq(ByteRange::new(file_id, start, end));
BinOpLt: BinOp<ByteRange> = <start: @L> "<" <end: @R> => BinOp::Lt(ByteRange::new(file_id, start, end));
BinOpLte: BinOp<ByteRange> = <start: @L> "<=" <end: @R> => BinOp::Lte(ByteRange::new(file_id, start, end));
BinOpGt: BinOp<ByteRange> = <start: @L> ">" <end: @R> => BinOp::Gt(ByteRange::new(file_id, start, end));
BinOpGte: BinOp<ByteRange> = <start: @L> ">=" <end: @R> => BinOp::Gte(ByteRange::new(file_id, start, end));

#[inline] Name: StringId = { <"name"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] Hole: StringId = { <"hole"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] StringLiteral: StringId = { <"string literal"> => interner.borrow_mut().get_or_intern(<>) };
#[inline] NumberLiteral: StringId = { <"number literal"> => interner.borrow_mut().get_or_intern(<>) };

#[inline]
RangedName: (ByteRange, StringId) = {
    <start: @L> <name: Name> <end: @R> => (ByteRange::new(file_id, start, end), name),
};

Seq<Elem, Sep>: &'arena [Elem] = {
    <elems: (<Elem> Sep)*> <last: Elem?> => {
        scope.to_scope_from_iter(elems.into_iter().chain(last))
    }
};

NonEmptySeq<Elem, Sep>: &'arena [Elem] = {
    <first: Elem> <elems: (Sep <Elem>)*> Sep? => {
        scope.to_scope_from_iter(std::iter::once(first).chain(elems))
    },
};
